{
   "_id": "_design/caCURE",
   "templates": {
       "forms": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<forms>\r\n{{#forms}}\r\n<form id=\"{{formId}}\" revision=\"{{revision}}\" ownerId=\"{{ownerId}}\" moduleId=\"{{moduleId}}\" instanceId=\"{{instanceId}}\"> \r\n    {{#questions}}\r\n\t<question id=\"{{questionId}}\" sn=\"{{questionSn}}\">\r\n        <text>{{questionText}}</text>\r\n        {{#answerValues}}\r\n\t\t<answer id=\"{{ansId}}\" text=\"{{ansText}}\">{{ansValue}}</answer>\r\n\t\t{{/answerValues}}\r\n    </question>\r\n\t{{/questions}}\r\n\t{{#complexTables}}\r\n\t<complex-table id=\"{{uuid}}\" sn=\"{{sn}}\" >\r\n\t\t<text>{{tableText}}</text>\r\n\t\t{{#rows}}\r\n\t\t<row>\r\n\t\t\t{{#columns}}\r\n\t\t\t<column id=\"{{questionId}}\" sn=\"{{questionSn}}\" isIdentifying=\"{{identifying}}\">\r\n\t\t\t\t<text>{{questionText}}</text>\r\n        \t\t{{#answerValues}}\r\n\t\t\t\t<answer id=\"{{ansId}}\" text=\"{{ansText}}\">{{ansValue}}</answer>\r\n\t\t\t\t{{/answerValues}}\r\n\t\t\t</column>\r\n\t\t\t{{/columns}}\r\n\t\t</row>\r\n\t\t{{/rows}}\r\n\t</complex-table>\r\n\t{{/complexTables}}\r\n\t{{#simpleTables}}\r\n\t<question-table id=\"{{uuid}}\" sn=\"{{sn}}\">\r\n\t\t<text>{{tableText}}</text>\r\n\t\t{{#questions}}\r\n\t\t<question id=\"{{questionId}}\" sn=\"{{questionSn}}\">\r\n        \t<text>{{questionText}}</text>\r\n        \t{{#answerValues}}\r\n\t\t\t<answer id=\"{{ansId}}\" text=\"{{ansText}}\">{{ansValue}}</answer>\r\n\t\t\t{{/answerValues}}\r\n    \t</question>\r\n\t\t{{/questions}}\r\n\t</question-table>\r\n\t{{/simpleTables}}\r\n</form>\r\n{{/forms}}\r\n</forms>",
       "formAllEntities": "<form xmlns=\"\" name=\"{{name}}\" id=\"{{formId}}\" revision=\"{{revision}}\" instanceId=\"{{instanceId}}\"> \r\n {{#owners}}\r\n    <owner id=\"{{ownerId}}\" >\r\n    <questions>\r\n    {{#questions}}\r\n\t<question id=\"{{questionId}}\" sn=\"{{questionSn}}\">\r\n        <text>{{questionText}}</text>\r\n        {{#answerValues}}\r\n\t\t<answer id=\"{{ansId}}\" text=\"{{ansText}}\">{{ansValue}}</answer>\r\n\t\t{{/answerValues}}\r\n    </question>\r\n\t{{/questions}}\r\n\t</questions>\r\n\t<complex-tables>\r\n\t{{#complexTables}}\r\n\t<complex-table id=\"{{uuid}}\" sn=\"{{sn}}\" >\r\n\t\t<text>{{tableText}}</text>\r\n\t\t{{#rows}}\r\n\t\t<row>\r\n\t\t\t{{#columns}}\r\n\t\t\t<column id=\"{{questionId}}\" sn=\"{{questionSn}}\" isIdentifying=\"{{identifying}}\">\r\n\t\t\t\t<text>{{questionText}}</text>\r\n        \t\t{{#answerValues}}\r\n\t\t\t\t<answer id=\"{{ansId}}\" text=\"{{ansText}}\">{{ansValue}}</answer>\r\n\t\t\t\t{{/answerValues}}\r\n\t\t\t</column>\r\n\t\t\t{{/columns}}\r\n\t\t</row>\r\n\t\t{{/rows}}\r\n\t</complex-table>\r\n\t{{/complexTables}}\r\n\t</complex-tables>\r\n\t<tables>\r\n\t{{#simpleTables}}\r\n\t<question-table id=\"{{uuid}}\" sn=\"{{sn}}\">\r\n\t\t<text>{{tableText}}</text>\r\n\t\t{{#questions}}\r\n\t\t<question id=\"{{questionId}}\" sn=\"{{questionSn}}\">\r\n        \t<text>{{questionText}}</text>\r\n        \t{{#answerValues}}\r\n\t\t\t<answer id=\"{{ansId}}\" text=\"{{ansText}}\">{{ansValue}}</answer>\r\n\t\t\t{{/answerValues}}\r\n    \t</question>\r\n\t\t{{/questions}}\r\n\t</question-table>\r\n\t{{/simpleTables}}\r\n\t</tables>\r\n\t</owner>\r\n  {{/owners}}\r\n</form>",
       "form": "<form xmlns=\"\" name=\"{{name}}\" id=\"{{formId}}\" revision=\"{{revision}}\" instanceId=\"{{instanceId}}\"> \r\n    {{#questions}}\r\n\t<question id=\"{{questionId}}\" sn=\"{{questionSn}}\">\r\n        <text>{{questionText}}</text>\r\n        {{#answerValues}}\r\n\t\t<answer id=\"{{ansId}}\" text=\"{{ansText}}\">{{ansValue}}</answer>\r\n\t\t{{/answerValues}}\r\n    </question>\r\n\t{{/questions}}\r\n\t{{#complexTables}}\r\n\t<complex-table id=\"{{uuid}}\" sn=\"{{sn}}\" >\r\n\t\t<text>{{tableText}}</text>\r\n\t\t{{#rows}}\r\n\t\t<row>\r\n\t\t\t{{#columns}}\r\n\t\t\t<column id=\"{{questionId}}\" sn=\"{{questionSn}}\" isIdentifying=\"{{identifying}}\">\r\n\t\t\t\t<text>{{questionText}}</text>\r\n        \t\t{{#answerValues}}\r\n\t\t\t\t<answer id=\"{{ansId}}\" text=\"{{ansText}}\">{{ansValue}}</answer>\r\n\t\t\t\t{{/answerValues}}\r\n\t\t\t</column>\r\n\t\t\t{{/columns}}\r\n\t\t</row>\r\n\t\t{{/rows}}\r\n\t</complex-table>\r\n\t{{/complexTables}}\r\n\t{{#simpleTables}}\r\n\t<question-table id=\"{{uuid}}\" sn=\"{{sn}}\">\r\n\t\t<text>{{tableText}}</text>\r\n\t\t{{#questions}}\r\n\t\t<question id=\"{{questionId}}\" sn=\"{{questionSn}}\">\r\n        \t<text>{{questionText}}</text>\r\n        \t{{#answerValues}}\r\n\t\t\t<answer id=\"{{ansId}}\" text=\"{{ansText}}\">{{ansValue}}</answer>\r\n\t\t\t{{/answerValues}}\r\n    \t</question>\r\n\t\t{{/questions}}\r\n\t</question-table>\r\n\t{{/simpleTables}}\r\n</form>"
   },
   "vendor": {
       "couchapp": {
           "README": "## CouchApp - more than just a filesystem mapper\n\nThis is where documentation will go for the client and server JavaScript parts of CouchApp.",
           "evently": {
               "profile": {
                   "profileReady": {
                       "after": "function(e, p) {\n  $$(this).profile = p;\n};",
                       "data": "function(e, p) {\n  return p\n}",
                       "mustache": "<div class=\"avatar\">\n  {{#gravatar_url}}<img src=\"{{gravatar_url}}\"/>{{/gravatar_url}}\n  <div class=\"name\">\n    {{nickname}}\n  </div>\n</div>\n<p>Hello {{nickname}}!</p>\n<div style=\"clear:left;\"></div>"
                   },
                   "noProfile": {
                       "data": "function(e, userCtx) {\n  return userCtx;\n}",
                       "mustache": "<form>\n  <p>Hello {{name}}, Please setup your user profile.</p>\n  <label for=\"nickname\">Nickname \n    <input type=\"text\" name=\"nickname\" value=\"\"></label>\n  <label for=\"email\">Email (<em>for <a href=\"http://gravatar.com\">Gravatar</a></em>)\n    <input type=\"text\" name=\"email\" value=\"\"></label>\n  <label for=\"url\">URL \n    <input type=\"text\" name=\"url\" value=\"\"></label>\n  <input type=\"submit\" value=\"Go &rarr;\">\n  <input type=\"hidden\" name=\"userCtxName\" value=\"{{name}}\" id=\"userCtxName\">\n</form>",
                       "selectors": {
                           "form": {
                               "submit": "function() {\n  var md5 = $$(this).app.require(\"vendor/couchapp/lib/md5\");\n  \n  // TODO this can be cleaned up with docForm?\n  // it still needs the workflow to edit an existing profile\n  var name = $(\"input[name=userCtxName]\",this).val();\n  var newProfile = {\n    rand : Math.random().toString(), \n    nickname : $(\"input[name=nickname]\",this).val(),\n    email : $(\"input[name=email]\",this).val(),\n    url : $(\"input[name=url]\",this).val()\n  }, widget = $(this);\n\n  // setup gravatar_url\n  if (md5) {\n    newProfile.gravatar_url = 'http://www.gravatar.com/avatar/'+md5.hex(newProfile.email || newProfile.rand)+'.jpg?s=40&d=identicon';    \n  }\n\n  // store the user profile on the user account document\n  $.couch.userDb(function(db) {\n    var userDocId = \"org.couchdb.user:\"+name;\n    db.openDoc(userDocId, {\n      success : function(userDoc) {\n        userDoc[\"couch.app.profile\"] = newProfile;\n        db.saveDoc(userDoc, {\n          success : function() {\n            newProfile.name = userDoc.name;\n            $$(widget).profile = newProfile;\n            widget.trigger(\"profileReady\", [newProfile]);\n          }\n        });\n      }\n    });\n  });\n  return false;\n}"
                           }
                       }
                   },
                   "loggedIn": "function(e, r) {\n  var userCtx = r.userCtx;\n  var widget = $(this);\n  // load the profile from the user doc\n  var db = $.couch.db(r.info.authentication_db);\n  var userDocId = \"org.couchdb.user:\"+userCtx.name;\n  db.openDoc(userDocId, {\n    success : function(userDoc) {\n      var profile = userDoc[\"couch.app.profile\"];\n      if (profile) {\n        // we copy the name to the profile so it can be used later\n        // without publishing the entire userdoc (roles, pass, etc)\n        profile.name = userDoc.name;\n        $$(widget).profile = profile;\n        widget.trigger(\"profileReady\", [profile]);\n      } else {\n        widget.trigger(\"noProfile\", [userCtx]);\n      }\n    }\n  });\n}",
                   "loggedOut": {
                       "after": "function() {\n  $$(this).profile = null;\n};",
                       "mustache": "<p>Please log in to see your profile.</p>"
                   }
               },
               "README": "## Starting the Document this code challenge\n\nI need help on this code. I only have so many hours in the day. Please be liberal about patching and hacking (and sharing code!) so we can all benefit. \n\nDocs patches are deeply appreciated. For now you can just stick Markdown files in the Docs directory.\n\n# Evently\n\nThese are some vendor Evently widgets that are running on the CouchApp system.\n\n## Account\n  This is how you signup, login and logout without worry about the code.\n  Todo, we could have this work against remote APIs like that Facebook stuff or whatever.\n\n\n## Profile\n  Use this to load the local users profile for the logged in user. Useful if you're going to be posting new messages. Most applications end up customizing `profile.profileReady` to render the primary data-entry form. This gets you benefits like refreshing on login / logout, etc, automatically.\n\n\n## Docs\n  This needs to be moved to it's own app.\n  I have this vision of a docs app designed for offline editing, that involves each Markdown paragraph being it's own document, with automatic use of Bespin for code samples. Any help on this would be thanked much.",
               "account": {
                   "loggedIn": {
                       "after": "function(e, r) {\n  $$(this).userCtx = r.userCtx;\n  $$(this).info = r.info;\n};",
                       "data": "function(e, r) {\n  return {\n    name : r.userCtx.name,\n    uri_name : encodeURIComponent(r.userCtx.name),\n    auth_db : encodeURIComponent(r.info.authentication_db)\n  };\n}",
                       "mustache": "<span>Welcome \n<a target=\"_new\" href=\"/_utils/document.html?{{auth_db}}/org.couchdb.user%3A{{uri_name}}\">{{name}}</a>! \n<a href=\"#logout\">Logout?</a>\n</span>",
                       "selectors": {
                           "a[href=#logout]": {
                               "click": [
                                   "doLogout"
                               ]
                           }
                       }
                   },
                   "signupForm": {
                       "after": "function() {\n  $(\"input[name=name]\", this).focus();\n}",
                       "mustache": "<form>\n  <label for=\"name\">Name</label> <input type=\"text\" name=\"name\" value=\"\">\n  <label for=\"password\">Password</label> <input type=\"password\" name=\"password\" value=\"\">\n  <input type=\"submit\" value=\"Signup\">\n  <a href=\"#login\">or Login</a>\n</form>",
                       "selectors": {
                           "a[href=#login]": {
                               "click": [
                                   "loginForm"
                               ]
                           },
                           "form": {
                               "submit": "function(e) {\n  var name = $('input[name=name]', this).val(),\n    pass = $('input[name=password]', this).val();              \n  $(this).trigger('doSignup', [name, pass]);\n  return false;\n}"
                           }
                       }
                   },
                   "_init": "function() {\n  var elem = $(this);\n  $$(this).userCtx = null;\n  $.couch.session({\n    success : function(r) {\n      var userCtx = r.userCtx;\n      if (userCtx.name) {\n        elem.trigger(\"loggedIn\", [r]);\n      } else if (userCtx.roles.indexOf(\"_admin\") != -1) {\n        elem.trigger(\"adminParty\");\n      } else {\n        elem.trigger(\"loggedOut\");\n      };\n    }\n  });\n}",
                   "doLogout": "function() {\n  var elem = $(this);\n  $.couch.logout({\n    success : function() {\n      elem.trigger(\"_init\");\n    }\n  });\n}",
                   "doSignup": "function(e, name, pass) {\n  var elem = $(this);\n  $.couch.signup({\n    name : name\n  }, pass, {\n    success : function() {\n      elem.trigger(\"doLogin\", [name, pass]);\n    }\n  });\n}",
                   "adminParty": {
                       "mustache": "<p><strong>Admin party, everyone is admin!</strong> Fix this in <a href=\"/_utils/index.html\">Futon</a> before proceeding.</p>"
                   },
                   "loggedOut": {
                       "mustache": "<a href=\"#signup\">Signup</a> or <a href=\"#login\">Login</a>",
                       "selectors": {
                           "a[href=#login]": {
                               "click": [
                                   "loginForm"
                               ]
                           },
                           "a[href=#signup]": {
                               "click": [
                                   "signupForm"
                               ]
                           }
                       }
                   },
                   "loginForm": {
                       "after": "function() {\n  $(\"input[name=name]\", this).focus();\n}",
                       "mustache": "<form>\n  <label for=\"name\">Name</label> <input type=\"text\" name=\"name\" value=\"\">\n  <label for=\"password\">Password</label> <input type=\"password\" name=\"password\" value=\"\">\n  <input type=\"submit\" value=\"Login\">\n  <a href=\"#signup\">or Signup</a>\n</form>",
                       "selectors": {
                           "form": {
                               "submit": "function(e) {\n  var name = $('input[name=name]', this).val(),\n    pass = $('input[name=password]', this).val();              \n  $(this).trigger('doLogin', [name, pass]);\n  return false;\n}"
                           },
                           "a[href=#signup]": {
                               "click": [
                                   "signupForm"
                               ]
                           }
                       }
                   },
                   "doLogin": "function(e, name, pass) {\n  var elem = $(this);\n  $.couch.login({\n    name : name,\n    password : pass,\n    success : function(r) {\n      elem.trigger(\"_init\")\n    }\n  });      \n}"
               }
           },
           "lib": {
               "redirect": "exports.permanent = function(redirect) {\n  return {\n    code : 301,\n    headers : {\n      \"Location\" : redirect\n    }\n  };\n};",
               "markdown": "//\n// showdown.js -- A javascript port of Markdown.\n//\n// Copyright (c) 2007 John Fraser.\n//\n// Original Markdown Copyright (c) 2004-2005 John Gruber\n//   <http://daringfireball.net/projects/markdown/>\n//\n// Redistributable under a BSD-style open source license.\n// See license.txt for more information.\n//\n// The full source distribution is at:\n//\n//\t\t\t\tA A L\n//\t\t\t\tT C A\n//\t\t\t\tT K B\n//\n//   <http://www.attacklab.net/>\n//\n\n//\n// Wherever possible, Showdown is a straight, line-by-line port\n// of the Perl version of Markdown.\n//\n// This is not a normal parser design; it's basically just a\n// series of string substitutions.  It's hard to read and\n// maintain this way,  but keeping Showdown close to the original\n// design makes it easier to port new features.\n//\n// More importantly, Showdown behaves like markdown.pl in most\n// edge cases.  So web applications can do client-side preview\n// in Javascript, and then build identical HTML on the server.\n//\n// This port needs the new RegExp functionality of ECMA 262,\n// 3rd Edition (i.e. Javascript 1.5).  Most modern web browsers\n// should do fine.  Even with the new regular expression features,\n// We do a lot of work to emulate Perl's regex functionality.\n// The tricky changes in this file mostly have the \"attacklab:\"\n// label.  Major or self-explanatory changes don't.\n//\n// Smart diff tools like Araxis Merge will be able to match up\n// this file with markdown.pl in a useful way.  A little tweaking\n// helps: in a copy of markdown.pl, replace \"#\" with \"//\" and\n// replace \"$text\" with \"text\".  Be sure to ignore whitespace\n// and line endings.\n//\n\n\n//\n// Showdown usage:\n//\n//   var text = \"Markdown *rocks*.\";\n//\n//   var markdown = require(\"markdown\");\n//   var html = markdown.encode(text);\n//\n//   print(html);\n//\n// Note: move the sample code to the bottom of this\n// file before uncommenting it.\n//\n\n\n//\n// Globals:\n//\n\n// Global hashes, used by various utility routines\nvar g_urls;\nvar g_titles;\nvar g_html_blocks;\n\n// Used to track when we're inside an ordered or unordered list\n// (see _ProcessListItems() for details):\nvar g_list_level = 0;\n\n\nexports.makeHtml = function(text) {\n//\n// Main function. The order in which other subs are called here is\n// essential. Link and image substitutions need to happen before\n// _EscapeSpecialCharsWithinTagAttributes(), so that any *'s or _'s in the <a>\n// and <img> tags get encoded.\n//\n\n\t// Clear the global hashes. If we don't clear these, you get conflicts\n\t// from other articles when generating a page which contains more than\n\t// one article (e.g. an index page that shows the N most recent\n\t// articles):\n\tg_urls = new Array();\n\tg_titles = new Array();\n\tg_html_blocks = new Array();\n\n\t// attacklab: Replace ~ with ~T\n\t// This lets us use tilde as an escape char to avoid md5 hashes\n\t// The choice of character is arbitray; anything that isn't\n    // magic in Markdown will work.\n\ttext = text.replace(/~/g,\"~T\");\n\n\t// attacklab: Replace $ with ~D\n\t// RegExp interprets $ as a special character\n\t// when it's in a replacement string\n\ttext = text.replace(/\\$/g,\"~D\");\n\n\t// Standardize line endings\n\ttext = text.replace(/\\r\\n/g,\"\\n\"); // DOS to Unix\n\ttext = text.replace(/\\r/g,\"\\n\"); // Mac to Unix\n\n\t// Make sure text begins and ends with a couple of newlines:\n\ttext = \"\\n\\n\" + text + \"\\n\\n\";\n\n\t// Convert all tabs to spaces.\n\ttext = _Detab(text);\n\n\t// Strip any lines consisting only of spaces and tabs.\n\t// This makes subsequent regexen easier to write, because we can\n\t// match consecutive blank lines with /\\n+/ instead of something\n\t// contorted like /[ \\t]*\\n+/ .\n\ttext = text.replace(/^[ \\t]+$/mg,\"\");\n\n\t// Turn block-level HTML blocks into hash entries\n\ttext = _HashHTMLBlocks(text);\n\n\t// Strip link definitions, store in hashes.\n\ttext = _StripLinkDefinitions(text);\n\n\ttext = _RunBlockGamut(text);\n\n\ttext = _UnescapeSpecialChars(text);\n\n\t// attacklab: Restore dollar signs\n\ttext = text.replace(/~D/g,\"$$\");\n\n\t// attacklab: Restore tildes\n\ttext = text.replace(/~T/g,\"~\");\n\treturn text;\n}\n\n\nvar _StripLinkDefinitions = function(text) {\n//\n// Strips link definitions from text, stores the URLs and titles in\n// hash references.\n//\n\n\t// Link defs are in the form: ^[id]: url \"optional title\"\n\n\t/*\n\t\tvar text = text.replace(/\n\t\t\t\t^[ ]{0,3}\\[(.+)\\]:  // id = $1  attacklab: g_tab_width - 1\n\t\t\t\t  [ \\t]*\n\t\t\t\t  \\n?\t\t\t\t// maybe *one* newline\n\t\t\t\t  [ \\t]*\n\t\t\t\t<?(\\S+?)>?\t\t\t// url = $2\n\t\t\t\t  [ \\t]*\n\t\t\t\t  \\n?\t\t\t\t// maybe one newline\n\t\t\t\t  [ \\t]*\n\t\t\t\t(?:\n\t\t\t\t  (\\n*)\t\t\t\t// any lines skipped = $3 attacklab: lookbehind removed\n\t\t\t\t  [\"(]\n\t\t\t\t  (.+?)\t\t\t\t// title = $4\n\t\t\t\t  [\")]\n\t\t\t\t  [ \\t]*\n\t\t\t\t)?\t\t\t\t\t// title is optional\n\t\t\t\t(?:\\n+|$)\n\t\t\t  /gm,\n\t\t\t  function(){...});\n\t*/\n\tvar text = text.replace(/^[ ]{0,3}\\[(.+)\\]:[ \\t]*\\n?[ \\t]*<?(\\S+?)>?[ \\t]*\\n?[ \\t]*(?:(\\n*)[\"(](.+?)[\")][ \\t]*)?(?:\\n+|\\Z)/gm,\n\t\tfunction (wholeMatch,m1,m2,m3,m4) {\n\t\t\tm1 = m1.toLowerCase();\n\t\t\tg_urls[m1] = _EncodeAmpsAndAngles(m2);  // Link IDs are case-insensitive\n\t\t\tif (m3) {\n\t\t\t\t// Oops, found blank lines, so it's not a title.\n\t\t\t\t// Put back the parenthetical statement we stole.\n\t\t\t\treturn m3+m4;\n\t\t\t} else if (m4) {\n\t\t\t\tg_titles[m1] = m4.replace(/\"/g,\"&quot;\");\n\t\t\t}\n\t\t\t\n\t\t\t// Completely remove the definition from the text\n\t\t\treturn \"\";\n\t\t}\n\t);\n\n\treturn text;\n}\n\n\nvar _HashHTMLBlocks = function(text) {\n\t// attacklab: Double up blank lines to reduce lookaround\n\ttext = text.replace(/\\n/g,\"\\n\\n\");\n\n\t// Hashify HTML blocks:\n\t// We only want to do this for block-level HTML tags, such as headers,\n\t// lists, and tables. That's because we still want to wrap <p>s around\n\t// \"paragraphs\" that are wrapped in non-block-level tags, such as anchors,\n\t// phrase emphasis, and spans. The list of tags we're looking for is\n\t// hard-coded:\n\tvar block_tags_a = \"p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math|ins|del\"\n\tvar block_tags_b = \"p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math\"\n\n\t// First, look for nested blocks, e.g.:\n\t//   <div>\n\t//     <div>\n\t//     tags for inner block must be indented.\n\t//     </div>\n\t//   </div>\n\t//\n\t// The outermost tags must start at the left margin for this to match, and\n\t// the inner nested divs must be indented.\n\t// We need to do this before the next, more liberal match, because the next\n\t// match will start at the first `<div>` and stop at the first `</div>`.\n\n\t// attacklab: This regex can be expensive when it fails.\n\t/*\n\t\tvar text = text.replace(/\n\t\t(\t\t\t\t\t\t// save in $1\n\t\t\t^\t\t\t\t\t// start of line  (with /m)\n\t\t\t<($block_tags_a)\t// start tag = $2\n\t\t\t\\b\t\t\t\t\t// word break\n\t\t\t\t\t\t\t\t// attacklab: hack around khtml/pcre bug...\n\t\t\t[^\\r]*?\\n\t\t\t// any number of lines, minimally matching\n\t\t\t</\\2>\t\t\t\t// the matching end tag\n\t\t\t[ \\t]*\t\t\t\t// trailing spaces/tabs\n\t\t\t(?=\\n+)\t\t\t\t// followed by a newline\n\t\t)\t\t\t\t\t\t// attacklab: there are sentinel newlines at end of document\n\t\t/gm,function(){...}};\n\t*/\n\ttext = text.replace(/^(<(p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math|ins|del)\\b[^\\r]*?\\n<\\/\\2>[ \\t]*(?=\\n+))/gm,hashElement);\n\n\t//\n\t// Now match more liberally, simply from `\\n<tag>` to `</tag>\\n`\n\t//\n\n\t/*\n\t\tvar text = text.replace(/\n\t\t(\t\t\t\t\t\t// save in $1\n\t\t\t^\t\t\t\t\t// start of line  (with /m)\n\t\t\t<($block_tags_b)\t// start tag = $2\n\t\t\t\\b\t\t\t\t\t// word break\n\t\t\t\t\t\t\t\t// attacklab: hack around khtml/pcre bug...\n\t\t\t[^\\r]*?\t\t\t\t// any number of lines, minimally matching\n\t\t\t.*</\\2>\t\t\t\t// the matching end tag\n\t\t\t[ \\t]*\t\t\t\t// trailing spaces/tabs\n\t\t\t(?=\\n+)\t\t\t\t// followed by a newline\n\t\t)\t\t\t\t\t\t// attacklab: there are sentinel newlines at end of document\n\t\t/gm,function(){...}};\n\t*/\n\ttext = text.replace(/^(<(p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math)\\b[^\\r]*?.*<\\/\\2>[ \\t]*(?=\\n+)\\n)/gm,hashElement);\n\n\t// Special case just for <hr />. It was easier to make a special case than\n\t// to make the other regex more complicated.  \n\n\t/*\n\t\ttext = text.replace(/\n\t\t(\t\t\t\t\t\t// save in $1\n\t\t\t\\n\\n\t\t\t\t// Starting after a blank line\n\t\t\t[ ]{0,3}\n\t\t\t(<(hr)\t\t\t\t// start tag = $2\n\t\t\t\\b\t\t\t\t\t// word break\n\t\t\t([^<>])*?\t\t\t// \n\t\t\t\\/?>)\t\t\t\t// the matching end tag\n\t\t\t[ \\t]*\n\t\t\t(?=\\n{2,})\t\t\t// followed by a blank line\n\t\t)\n\t\t/g,hashElement);\n\t*/\n\ttext = text.replace(/(\\n[ ]{0,3}(<(hr)\\b([^<>])*?\\/?>)[ \\t]*(?=\\n{2,}))/g,hashElement);\n\n\t// Special case for standalone HTML comments:\n\n\t/*\n\t\ttext = text.replace(/\n\t\t(\t\t\t\t\t\t// save in $1\n\t\t\t\\n\\n\t\t\t\t// Starting after a blank line\n\t\t\t[ ]{0,3}\t\t\t// attacklab: g_tab_width - 1\n\t\t\t<!\n\t\t\t(--[^\\r]*?--\\s*)+\n\t\t\t>\n\t\t\t[ \\t]*\n\t\t\t(?=\\n{2,})\t\t\t// followed by a blank line\n\t\t)\n\t\t/g,hashElement);\n\t*/\n\ttext = text.replace(/(\\n\\n[ ]{0,3}<!(--[^\\r]*?--\\s*)+>[ \\t]*(?=\\n{2,}))/g,hashElement);\n\n\t// PHP and ASP-style processor instructions (<?...?> and <%...%>)\n\n\t/*\n\t\ttext = text.replace(/\n\t\t(?:\n\t\t\t\\n\\n\t\t\t\t// Starting after a blank line\n\t\t)\n\t\t(\t\t\t\t\t\t// save in $1\n\t\t\t[ ]{0,3}\t\t\t// attacklab: g_tab_width - 1\n\t\t\t(?:\n\t\t\t\t<([?%])\t\t\t// $2\n\t\t\t\t[^\\r]*?\n\t\t\t\t\\2>\n\t\t\t)\n\t\t\t[ \\t]*\n\t\t\t(?=\\n{2,})\t\t\t// followed by a blank line\n\t\t)\n\t\t/g,hashElement);\n\t*/\n\ttext = text.replace(/(?:\\n\\n)([ ]{0,3}(?:<([?%])[^\\r]*?\\2>)[ \\t]*(?=\\n{2,}))/g,hashElement);\n\n\t// attacklab: Undo double lines (see comment at top of this function)\n\ttext = text.replace(/\\n\\n/g,\"\\n\");\n\treturn text;\n}\n\nvar hashElement = function(wholeMatch,m1) {\n\tvar blockText = m1;\n\n\t// Undo double lines\n\tblockText = blockText.replace(/\\n\\n/g,\"\\n\");\n\tblockText = blockText.replace(/^\\n/,\"\");\n\t\n\t// strip trailing blank lines\n\tblockText = blockText.replace(/\\n+$/g,\"\");\n\t\n\t// Replace the element text with a marker (\"~KxK\" where x is its key)\n\tblockText = \"\\n\\n~K\" + (g_html_blocks.push(blockText)-1) + \"K\\n\\n\";\n\t\n\treturn blockText;\n};\n\nvar _RunBlockGamut = function(text) {\n//\n// These are all the transformations that form block-level\n// tags like paragraphs, headers, and list items.\n//\n\ttext = _DoHeaders(text);\n\n\t// Do Horizontal Rules:\n\tvar key = hashBlock(\"<hr />\");\n\ttext = text.replace(/^[ ]{0,2}([ ]?\\*[ ]?){3,}[ \\t]*$/gm,key);\n\ttext = text.replace(/^[ ]{0,2}([ ]?\\-[ ]?){3,}[ \\t]*$/gm,key);\n\ttext = text.replace(/^[ ]{0,2}([ ]?\\_[ ]?){3,}[ \\t]*$/gm,key);\n\n\ttext = _DoLists(text);\n\ttext = _DoCodeBlocks(text);\n\ttext = _DoBlockQuotes(text);\n\n\t// We already ran _HashHTMLBlocks() before, in Markdown(), but that\n\t// was to escape raw HTML in the original Markdown source. This time,\n\t// we're escaping the markup we've just created, so that we don't wrap\n\t// <p> tags around block-level tags.\n\ttext = _HashHTMLBlocks(text);\n\ttext = _FormParagraphs(text);\n\n\treturn text;\n}\n\n\nvar _RunSpanGamut = function(text) {\n//\n// These are all the transformations that occur *within* block-level\n// tags like paragraphs, headers, and list items.\n//\n\n\ttext = _DoCodeSpans(text);\n\ttext = _EscapeSpecialCharsWithinTagAttributes(text);\n\ttext = _EncodeBackslashEscapes(text);\n\n\t// Process anchor and image tags. Images must come first,\n\t// because ![foo][f] looks like an anchor.\n\ttext = _DoImages(text);\n\ttext = _DoAnchors(text);\n\n\t// Make links out of things like `<http://example.com/>`\n\t// Must come after _DoAnchors(), because you can use < and >\n\t// delimiters in inline links like [this](<url>).\n\ttext = _DoAutoLinks(text);\n\ttext = _EncodeAmpsAndAngles(text);\n\ttext = _DoItalicsAndBold(text);\n\n\t// Do hard breaks:\n\ttext = text.replace(/  +\\n/g,\" <br />\\n\");\n\n\treturn text;\n}\n\nvar _EscapeSpecialCharsWithinTagAttributes = function(text) {\n//\n// Within tags -- meaning between < and > -- encode [\\ ` * _] so they\n// don't conflict with their use in Markdown for code, italics and strong.\n//\n\n\t// Build a regex to find HTML tags and comments.  See Friedl's \n\t// \"Mastering Regular Expressions\", 2nd Ed., pp. 200-201.\n\tvar regex = /(<[a-z\\/!$](\"[^\"]*\"|'[^']*'|[^'\">])*>|<!(--.*?--\\s*)+>)/gi;\n\n\ttext = text.replace(regex, function(wholeMatch) {\n\t\tvar tag = wholeMatch.replace(/(.)<\\/?code>(?=.)/g,\"$1`\");\n\t\ttag = escapeCharacters(tag,\"\\\\`*_\");\n\t\treturn tag;\n\t});\n\n\treturn text;\n}\n\nvar _DoAnchors = function(text) {\n//\n// Turn Markdown link shortcuts into XHTML <a> tags.\n//\n\t//\n\t// First, handle reference-style links: [link text] [id]\n\t//\n\n\t/*\n\t\ttext = text.replace(/\n\t\t(\t\t\t\t\t\t\t// wrap whole match in $1\n\t\t\t\\[\n\t\t\t(\n\t\t\t\t(?:\n\t\t\t\t\t\\[[^\\]]*\\]\t\t// allow brackets nested one level\n\t\t\t\t\t|\n\t\t\t\t\t[^\\[]\t\t\t// or anything else\n\t\t\t\t)*\n\t\t\t)\n\t\t\t\\]\n\n\t\t\t[ ]?\t\t\t\t\t// one optional space\n\t\t\t(?:\\n[ ]*)?\t\t\t\t// one optional newline followed by spaces\n\n\t\t\t\\[\n\t\t\t(.*?)\t\t\t\t\t// id = $3\n\t\t\t\\]\n\t\t)()()()()\t\t\t\t\t// pad remaining backreferences\n\t\t/g,_DoAnchors_callback);\n\t*/\n\ttext = text.replace(/(\\[((?:\\[[^\\]]*\\]|[^\\[\\]])*)\\][ ]?(?:\\n[ ]*)?\\[(.*?)\\])()()()()/g,writeAnchorTag);\n\n\t//\n\t// Next, inline-style links: [link text](url \"optional title\")\n\t//\n\n\t/*\n\t\ttext = text.replace(/\n\t\t\t(\t\t\t\t\t\t// wrap whole match in $1\n\t\t\t\t\\[\n\t\t\t\t(\n\t\t\t\t\t(?:\n\t\t\t\t\t\t\\[[^\\]]*\\]\t// allow brackets nested one level\n\t\t\t\t\t|\n\t\t\t\t\t[^\\[\\]]\t\t\t// or anything else\n\t\t\t\t)\n\t\t\t)\n\t\t\t\\]\n\t\t\t\\(\t\t\t\t\t\t// literal paren\n\t\t\t[ \\t]*\n\t\t\t()\t\t\t\t\t\t// no id, so leave $3 empty\n\t\t\t<?(.*?)>?\t\t\t\t// href = $4\n\t\t\t[ \\t]*\n\t\t\t(\t\t\t\t\t\t// $5\n\t\t\t\t(['\"])\t\t\t\t// quote char = $6\n\t\t\t\t(.*?)\t\t\t\t// Title = $7\n\t\t\t\t\\6\t\t\t\t\t// matching quote\n\t\t\t\t[ \\t]*\t\t\t\t// ignore any spaces/tabs between closing quote and )\n\t\t\t)?\t\t\t\t\t\t// title is optional\n\t\t\t\\)\n\t\t)\n\t\t/g,writeAnchorTag);\n\t*/\n\ttext = text.replace(/(\\[((?:\\[[^\\]]*\\]|[^\\[\\]])*)\\]\\([ \\t]*()<?(.*?)>?[ \\t]*((['\"])(.*?)\\6[ \\t]*)?\\))/g,writeAnchorTag);\n\n\t//\n\t// Last, handle reference-style shortcuts: [link text]\n\t// These must come last in case you've also got [link test][1]\n\t// or [link test](/foo)\n\t//\n\n\t/*\n\t\ttext = text.replace(/\n\t\t(\t\t \t\t\t\t\t// wrap whole match in $1\n\t\t\t\\[\n\t\t\t([^\\[\\]]+)\t\t\t\t// link text = $2; can't contain '[' or ']'\n\t\t\t\\]\n\t\t)()()()()()\t\t\t\t\t// pad rest of backreferences\n\t\t/g, writeAnchorTag);\n\t*/\n\ttext = text.replace(/(\\[([^\\[\\]]+)\\])()()()()()/g, writeAnchorTag);\n\n\treturn text;\n}\n\nvar writeAnchorTag = function(wholeMatch,m1,m2,m3,m4,m5,m6,m7) {\n\tif (m7 == undefined) m7 = \"\";\n\tvar whole_match = m1;\n\tvar link_text   = m2;\n\tvar link_id\t = m3.toLowerCase();\n\tvar url\t\t= m4;\n\tvar title\t= m7;\n\t\n\tif (url == \"\") {\n\t\tif (link_id == \"\") {\n\t\t\t// lower-case and turn embedded newlines into spaces\n\t\t\tlink_id = link_text.toLowerCase().replace(/ ?\\n/g,\" \");\n\t\t}\n\t\turl = \"#\"+link_id;\n\t\t\n\t\tif (g_urls[link_id] != undefined) {\n\t\t\turl = g_urls[link_id];\n\t\t\tif (g_titles[link_id] != undefined) {\n\t\t\t\ttitle = g_titles[link_id];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (whole_match.search(/\\(\\s*\\)$/m)>-1) {\n\t\t\t\t// Special case for explicit empty url\n\t\t\t\turl = \"\";\n\t\t\t} else {\n\t\t\t\treturn whole_match;\n\t\t\t}\n\t\t}\n\t}\t\n\t\n\turl = escapeCharacters(url,\"*_\");\n\tvar result = \"<a href=\\\"\" + url + \"\\\"\";\n\t\n\tif (title != \"\") {\n\t\ttitle = title.replace(/\"/g,\"&quot;\");\n\t\ttitle = escapeCharacters(title,\"*_\");\n\t\tresult +=  \" title=\\\"\" + title + \"\\\"\";\n\t}\n\t\n\tresult += \">\" + link_text + \"</a>\";\n\t\n\treturn result;\n}\n\n\nvar _DoImages = function(text) {\n//\n// Turn Markdown image shortcuts into <img> tags.\n//\n\n\t//\n\t// First, handle reference-style labeled images: ![alt text][id]\n\t//\n\n\t/*\n\t\ttext = text.replace(/\n\t\t(\t\t\t\t\t\t// wrap whole match in $1\n\t\t\t!\\[\n\t\t\t(.*?)\t\t\t\t// alt text = $2\n\t\t\t\\]\n\n\t\t\t[ ]?\t\t\t\t// one optional space\n\t\t\t(?:\\n[ ]*)?\t\t\t// one optional newline followed by spaces\n\n\t\t\t\\[\n\t\t\t(.*?)\t\t\t\t// id = $3\n\t\t\t\\]\n\t\t)()()()()\t\t\t\t// pad rest of backreferences\n\t\t/g,writeImageTag);\n\t*/\n\ttext = text.replace(/(!\\[(.*?)\\][ ]?(?:\\n[ ]*)?\\[(.*?)\\])()()()()/g,writeImageTag);\n\n\t//\n\t// Next, handle inline images:  ![alt text](url \"optional title\")\n\t// Don't forget: encode * and _\n\n\t/*\n\t\ttext = text.replace(/\n\t\t(\t\t\t\t\t\t// wrap whole match in $1\n\t\t\t!\\[\n\t\t\t(.*?)\t\t\t\t// alt text = $2\n\t\t\t\\]\n\t\t\t\\s?\t\t\t\t\t// One optional whitespace character\n\t\t\t\\(\t\t\t\t\t// literal paren\n\t\t\t[ \\t]*\n\t\t\t()\t\t\t\t\t// no id, so leave $3 empty\n\t\t\t<?(\\S+?)>?\t\t\t// src url = $4\n\t\t\t[ \\t]*\n\t\t\t(\t\t\t\t\t// $5\n\t\t\t\t(['\"])\t\t\t// quote char = $6\n\t\t\t\t(.*?)\t\t\t// title = $7\n\t\t\t\t\\6\t\t\t\t// matching quote\n\t\t\t\t[ \\t]*\n\t\t\t)?\t\t\t\t\t// title is optional\n\t\t\\)\n\t\t)\n\t\t/g,writeImageTag);\n\t*/\n\ttext = text.replace(/(!\\[(.*?)\\]\\s?\\([ \\t]*()<?(\\S+?)>?[ \\t]*((['\"])(.*?)\\6[ \\t]*)?\\))/g,writeImageTag);\n\n\treturn text;\n}\n\nvar writeImageTag = function(wholeMatch,m1,m2,m3,m4,m5,m6,m7) {\n\tvar whole_match = m1;\n\tvar alt_text   = m2;\n\tvar link_id\t = m3.toLowerCase();\n\tvar url\t\t= m4;\n\tvar title\t= m7;\n\n\tif (!title) title = \"\";\n\t\n\tif (url == \"\") {\n\t\tif (link_id == \"\") {\n\t\t\t// lower-case and turn embedded newlines into spaces\n\t\t\tlink_id = alt_text.toLowerCase().replace(/ ?\\n/g,\" \");\n\t\t}\n\t\turl = \"#\"+link_id;\n\t\t\n\t\tif (g_urls[link_id] != undefined) {\n\t\t\turl = g_urls[link_id];\n\t\t\tif (g_titles[link_id] != undefined) {\n\t\t\t\ttitle = g_titles[link_id];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\treturn whole_match;\n\t\t}\n\t}\t\n\t\n\talt_text = alt_text.replace(/\"/g,\"&quot;\");\n\turl = escapeCharacters(url,\"*_\");\n\tvar result = \"<img src=\\\"\" + url + \"\\\" alt=\\\"\" + alt_text + \"\\\"\";\n\n\t// attacklab: Markdown.pl adds empty title attributes to images.\n\t// Replicate this bug.\n\n\t//if (title != \"\") {\n\t\ttitle = title.replace(/\"/g,\"&quot;\");\n\t\ttitle = escapeCharacters(title,\"*_\");\n\t\tresult +=  \" title=\\\"\" + title + \"\\\"\";\n\t//}\n\t\n\tresult += \" />\";\n\t\n\treturn result;\n}\n\n\nvar _DoHeaders = function(text) {\n\n\t// Setext-style headers:\n\t//\tHeader 1\n\t//\t========\n\t//  \n\t//\tHeader 2\n\t//\t--------\n\t//\n\ttext = text.replace(/^(.+)[ \\t]*\\n=+[ \\t]*\\n+/gm,\n\t\tfunction(wholeMatch,m1){return hashBlock(\"<h1>\" + _RunSpanGamut(m1) + \"</h1>\");});\n\n\ttext = text.replace(/^(.+)[ \\t]*\\n-+[ \\t]*\\n+/gm,\n\t\tfunction(matchFound,m1){return hashBlock(\"<h2>\" + _RunSpanGamut(m1) + \"</h2>\");});\n\n\t// atx-style headers:\n\t//  # Header 1\n\t//  ## Header 2\n\t//  ## Header 2 with closing hashes ##\n\t//  ...\n\t//  ###### Header 6\n\t//\n\n\t/*\n\t\ttext = text.replace(/\n\t\t\t^(\\#{1,6})\t\t\t\t// $1 = string of #'s\n\t\t\t[ \\t]*\n\t\t\t(.+?)\t\t\t\t\t// $2 = Header text\n\t\t\t[ \\t]*\n\t\t\t\\#*\t\t\t\t\t\t// optional closing #'s (not counted)\n\t\t\t\\n+\n\t\t/gm, function() {...});\n\t*/\n\n\ttext = text.replace(/^(\\#{1,6})[ \\t]*(.+?)[ \\t]*\\#*\\n+/gm,\n\t\tfunction(wholeMatch,m1,m2) {\n\t\t\tvar h_level = m1.length;\n\t\t\treturn hashBlock(\"<h\" + h_level + \">\" + _RunSpanGamut(m2) + \"</h\" + h_level + \">\");\n\t\t});\n\n\treturn text;\n}\n\n// This declaration keeps Dojo compressor from outputting garbage:\nvar _ProcessListItems;\n\nvar _DoLists = function(text) {\n//\n// Form HTML ordered (numbered) and unordered (bulleted) lists.\n//\n\n\t// attacklab: add sentinel to hack around khtml/safari bug:\n\t// http://bugs.webkit.org/show_bug.cgi?id=11231\n\ttext += \"~0\";\n\n\t// Re-usable pattern to match any entirel ul or ol list:\n\n\t/*\n\t\tvar whole_list = /\n\t\t(\t\t\t\t\t\t\t\t\t// $1 = whole list\n\t\t\t(\t\t\t\t\t\t\t\t// $2\n\t\t\t\t[ ]{0,3}\t\t\t\t\t// attacklab: g_tab_width - 1\n\t\t\t\t([*+-]|\\d+[.])\t\t\t\t// $3 = first list item marker\n\t\t\t\t[ \\t]+\n\t\t\t)\n\t\t\t[^\\r]+?\n\t\t\t(\t\t\t\t\t\t\t\t// $4\n\t\t\t\t~0\t\t\t\t\t\t\t// sentinel for workaround; should be $\n\t\t\t|\n\t\t\t\t\\n{2,}\n\t\t\t\t(?=\\S)\n\t\t\t\t(?!\t\t\t\t\t\t\t// Negative lookahead for another list item marker\n\t\t\t\t\t[ \\t]*\n\t\t\t\t\t(?:[*+-]|\\d+[.])[ \\t]+\n\t\t\t\t)\n\t\t\t)\n\t\t)/g\n\t*/\n\tvar whole_list = /^(([ ]{0,3}([*+-]|\\d+[.])[ \\t]+)[^\\r]+?(~0|\\n{2,}(?=\\S)(?![ \\t]*(?:[*+-]|\\d+[.])[ \\t]+)))/gm;\n\n\tif (g_list_level) {\n\t\ttext = text.replace(whole_list,function(wholeMatch,m1,m2) {\n\t\t\tvar list = m1;\n\t\t\tvar list_type = (m2.search(/[*+-]/g)>-1) ? \"ul\" : \"ol\";\n\n\t\t\t// Turn double returns into triple returns, so that we can make a\n\t\t\t// paragraph for the last item in a list, if necessary:\n\t\t\tlist = list.replace(/\\n{2,}/g,\"\\n\\n\\n\");;\n\t\t\tvar result = _ProcessListItems(list);\n\t\n\t\t\t// Trim any trailing whitespace, to put the closing `</$list_type>`\n\t\t\t// up on the preceding line, to get it past the current stupid\n\t\t\t// HTML block parser. This is a hack to work around the terrible\n\t\t\t// hack that is the HTML block parser.\n\t\t\tresult = result.replace(/\\s+$/,\"\");\n\t\t\tresult = \"<\"+list_type+\">\" + result + \"</\"+list_type+\">\\n\";\n\t\t\treturn result;\n\t\t});\n\t} else {\n\t\twhole_list = /(\\n\\n|^\\n?)(([ ]{0,3}([*+-]|\\d+[.])[ \\t]+)[^\\r]+?(~0|\\n{2,}(?=\\S)(?![ \\t]*(?:[*+-]|\\d+[.])[ \\t]+)))/g;\n\t\ttext = text.replace(whole_list,function(wholeMatch,m1,m2,m3) {\n\t\t\tvar runup = m1;\n\t\t\tvar list = m2;\n\n\t\t\tvar list_type = (m3.search(/[*+-]/g)>-1) ? \"ul\" : \"ol\";\n\t\t\t// Turn double returns into triple returns, so that we can make a\n\t\t\t// paragraph for the last item in a list, if necessary:\n\t\t\tvar list = list.replace(/\\n{2,}/g,\"\\n\\n\\n\");;\n\t\t\tvar result = _ProcessListItems(list);\n\t\t\tresult = runup + \"<\"+list_type+\">\\n\" + result + \"</\"+list_type+\">\\n\";\t\n\t\t\treturn result;\n\t\t});\n\t}\n\n\t// attacklab: strip sentinel\n\ttext = text.replace(/~0/,\"\");\n\n\treturn text;\n}\n\n_ProcessListItems = function(list_str) {\n//\n//  Process the contents of a single ordered or unordered list, splitting it\n//  into individual list items.\n//\n\t// The $g_list_level global keeps track of when we're inside a list.\n\t// Each time we enter a list, we increment it; when we leave a list,\n\t// we decrement. If it's zero, we're not in a list anymore.\n\t//\n\t// We do this because when we're not inside a list, we want to treat\n\t// something like this:\n\t//\n\t//    I recommend upgrading to version\n\t//    8. Oops, now this line is treated\n\t//    as a sub-list.\n\t//\n\t// As a single paragraph, despite the fact that the second line starts\n\t// with a digit-period-space sequence.\n\t//\n\t// Whereas when we're inside a list (or sub-list), that line will be\n\t// treated as the start of a sub-list. What a kludge, huh? This is\n\t// an aspect of Markdown's syntax that's hard to parse perfectly\n\t// without resorting to mind-reading. Perhaps the solution is to\n\t// change the syntax rules such that sub-lists must start with a\n\t// starting cardinal number; e.g. \"1.\" or \"a.\".\n\n\tg_list_level++;\n\n\t// trim trailing blank lines:\n\tlist_str = list_str.replace(/\\n{2,}$/,\"\\n\");\n\n\t// attacklab: add sentinel to emulate \\z\n\tlist_str += \"~0\";\n\n\t/*\n\t\tlist_str = list_str.replace(/\n\t\t\t(\\n)?\t\t\t\t\t\t\t// leading line = $1\n\t\t\t(^[ \\t]*)\t\t\t\t\t\t// leading whitespace = $2\n\t\t\t([*+-]|\\d+[.]) [ \\t]+\t\t\t// list marker = $3\n\t\t\t([^\\r]+?\t\t\t\t\t\t// list item text   = $4\n\t\t\t(\\n{1,2}))\n\t\t\t(?= \\n* (~0 | \\2 ([*+-]|\\d+[.]) [ \\t]+))\n\t\t/gm, function(){...});\n\t*/\n\tlist_str = list_str.replace(/(\\n)?(^[ \\t]*)([*+-]|\\d+[.])[ \\t]+([^\\r]+?(\\n{1,2}))(?=\\n*(~0|\\2([*+-]|\\d+[.])[ \\t]+))/gm,\n\t\tfunction(wholeMatch,m1,m2,m3,m4){\n\t\t\tvar item = m4;\n\t\t\tvar leading_line = m1;\n\t\t\tvar leading_space = m2;\n\n\t\t\tif (leading_line || (item.search(/\\n{2,}/)>-1)) {\n\t\t\t\titem = _RunBlockGamut(_Outdent(item));\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Recursion for sub-lists:\n\t\t\t\titem = _DoLists(_Outdent(item));\n\t\t\t\titem = item.replace(/\\n$/,\"\"); // chomp(item)\n\t\t\t\titem = _RunSpanGamut(item);\n\t\t\t}\n\n\t\t\treturn  \"<li>\" + item + \"</li>\\n\";\n\t\t}\n\t);\n\n\t// attacklab: strip sentinel\n\tlist_str = list_str.replace(/~0/g,\"\");\n\n\tg_list_level--;\n\treturn list_str;\n}\n\n\nvar _DoCodeBlocks = function(text) {\n//\n//  Process Markdown `<pre><code>` blocks.\n//  \n\n\t/*\n\t\ttext = text.replace(text,\n\t\t\t/(?:\\n\\n|^)\n\t\t\t(\t\t\t\t\t\t\t\t// $1 = the code block -- one or more lines, starting with a space/tab\n\t\t\t\t(?:\n\t\t\t\t\t(?:[ ]{4}|\\t)\t\t\t// Lines must start with a tab or a tab-width of spaces - attacklab: g_tab_width\n\t\t\t\t\t.*\\n+\n\t\t\t\t)+\n\t\t\t)\n\t\t\t(\\n*[ ]{0,3}[^ \\t\\n]|(?=~0))\t// attacklab: g_tab_width\n\t\t/g,function(){...});\n\t*/\n\n\t// attacklab: sentinel workarounds for lack of \\A and \\Z, safari\\khtml bug\n\ttext += \"~0\";\n\t\n\ttext = text.replace(/(?:\\n\\n|^)((?:(?:[ ]{4}|\\t).*\\n+)+)(\\n*[ ]{0,3}[^ \\t\\n]|(?=~0))/g,\n\t\tfunction(wholeMatch,m1,m2) {\n\t\t\tvar codeblock = m1;\n\t\t\tvar nextChar = m2;\n\t\t\n\t\t\tcodeblock = _EncodeCode( _Outdent(codeblock));\n\t\t\tcodeblock = _Detab(codeblock);\n\t\t\tcodeblock = codeblock.replace(/^\\n+/g,\"\"); // trim leading newlines\n\t\t\tcodeblock = codeblock.replace(/\\n+$/g,\"\"); // trim trailing whitespace\n\n\t\t\tcodeblock = \"<pre><code>\" + codeblock + \"\\n</code></pre>\";\n\n\t\t\treturn hashBlock(codeblock) + nextChar;\n\t\t}\n\t);\n\n\t// attacklab: strip sentinel\n\ttext = text.replace(/~0/,\"\");\n\n\treturn text;\n}\n\nvar hashBlock = function(text) {\n\ttext = text.replace(/(^\\n+|\\n+$)/g,\"\");\n\treturn \"\\n\\n~K\" + (g_html_blocks.push(text)-1) + \"K\\n\\n\";\n}\n\n\nvar _DoCodeSpans = function(text) {\n//\n//   *  Backtick quotes are used for <code></code> spans.\n// \n//   *  You can use multiple backticks as the delimiters if you want to\n//\t include literal backticks in the code span. So, this input:\n//\t \n//\t\t Just type ``foo `bar` baz`` at the prompt.\n//\t \n//\t   Will translate to:\n//\t \n//\t\t <p>Just type <code>foo `bar` baz</code> at the prompt.</p>\n//\t \n//\tThere's no arbitrary limit to the number of backticks you\n//\tcan use as delimters. If you need three consecutive backticks\n//\tin your code, use four for delimiters, etc.\n//\n//  *  You can use spaces to get literal backticks at the edges:\n//\t \n//\t\t ... type `` `bar` `` ...\n//\t \n//\t   Turns to:\n//\t \n//\t\t ... type <code>`bar`</code> ...\n//\n\n\t/*\n\t\ttext = text.replace(/\n\t\t\t(^|[^\\\\])\t\t\t\t\t// Character before opening ` can't be a backslash\n\t\t\t(`+)\t\t\t\t\t\t// $2 = Opening run of `\n\t\t\t(\t\t\t\t\t\t\t// $3 = The code block\n\t\t\t\t[^\\r]*?\n\t\t\t\t[^`]\t\t\t\t\t// attacklab: work around lack of lookbehind\n\t\t\t)\n\t\t\t\\2\t\t\t\t\t\t\t// Matching closer\n\t\t\t(?!`)\n\t\t/gm, function(){...});\n\t*/\n\n\ttext = text.replace(/(^|[^\\\\])(`+)([^\\r]*?[^`])\\2(?!`)/gm,\n\t\tfunction(wholeMatch,m1,m2,m3,m4) {\n\t\t\tvar c = m3;\n\t\t\tc = c.replace(/^([ \\t]*)/g,\"\");\t// leading whitespace\n\t\t\tc = c.replace(/[ \\t]*$/g,\"\");\t// trailing whitespace\n\t\t\tc = _EncodeCode(c);\n\t\t\treturn m1+\"<code>\"+c+\"</code>\";\n\t\t});\n\n\treturn text;\n}\n\n\nvar _EncodeCode = function(text) {\n//\n// Encode/escape certain characters inside Markdown code runs.\n// The point is that in code, these characters are literals,\n// and lose their special Markdown meanings.\n//\n\t// Encode all ampersands; HTML entities are not\n\t// entities within a Markdown code span.\n\ttext = text.replace(/&/g,\"&amp;\");\n\n\t// Do the angle bracket song and dance:\n\ttext = text.replace(/</g,\"&lt;\");\n\ttext = text.replace(/>/g,\"&gt;\");\n\n\t// Now, escape characters that are magic in Markdown:\n\ttext = escapeCharacters(text,\"\\*_{}[]\\\\\",false);\n\n// jj the line above breaks this:\n//---\n\n//* Item\n\n//   1. Subitem\n\n//            special char: *\n//---\n\n\treturn text;\n}\n\n\nvar _DoItalicsAndBold = function(text) {\n\n\t// <strong> must go first:\n\ttext = text.replace(/(\\*\\*|__)(?=\\S)([^\\r]*?\\S[*_]*)\\1/g,\n\t\t\"<strong>$2</strong>\");\n\n\ttext = text.replace(/(\\*|_)(?=\\S)([^\\r]*?\\S)\\1/g,\n\t\t\"<em>$2</em>\");\n\n\treturn text;\n}\n\n\nvar _DoBlockQuotes = function(text) {\n\n\t/*\n\t\ttext = text.replace(/\n\t\t(\t\t\t\t\t\t\t\t// Wrap whole match in $1\n\t\t\t(\n\t\t\t\t^[ \\t]*>[ \\t]?\t\t\t// '>' at the start of a line\n\t\t\t\t.+\\n\t\t\t\t\t// rest of the first line\n\t\t\t\t(.+\\n)*\t\t\t\t\t// subsequent consecutive lines\n\t\t\t\t\\n*\t\t\t\t\t\t// blanks\n\t\t\t)+\n\t\t)\n\t\t/gm, function(){...});\n\t*/\n\n\ttext = text.replace(/((^[ \\t]*>[ \\t]?.+\\n(.+\\n)*\\n*)+)/gm,\n\t\tfunction(wholeMatch,m1) {\n\t\t\tvar bq = m1;\n\n\t\t\t// attacklab: hack around Konqueror 3.5.4 bug:\n\t\t\t// \"----------bug\".replace(/^-/g,\"\") == \"bug\"\n\n\t\t\tbq = bq.replace(/^[ \\t]*>[ \\t]?/gm,\"~0\");\t// trim one level of quoting\n\n\t\t\t// attacklab: clean up hack\n\t\t\tbq = bq.replace(/~0/g,\"\");\n\n\t\t\tbq = bq.replace(/^[ \\t]+$/gm,\"\");\t\t// trim whitespace-only lines\n\t\t\tbq = _RunBlockGamut(bq);\t\t\t\t// recurse\n\t\t\t\n\t\t\tbq = bq.replace(/(^|\\n)/g,\"$1  \");\n\t\t\t// These leading spaces screw with <pre> content, so we need to fix that:\n\t\t\tbq = bq.replace(\n\t\t\t\t\t/(\\s*<pre>[^\\r]+?<\\/pre>)/gm,\n\t\t\t\tfunction(wholeMatch,m1) {\n\t\t\t\t\tvar pre = m1;\n\t\t\t\t\t// attacklab: hack around Konqueror 3.5.4 bug:\n\t\t\t\t\tpre = pre.replace(/^  /mg,\"~0\");\n\t\t\t\t\tpre = pre.replace(/~0/g,\"\");\n\t\t\t\t\treturn pre;\n\t\t\t\t});\n\t\t\t\n\t\t\treturn hashBlock(\"<blockquote>\\n\" + bq + \"\\n</blockquote>\");\n\t\t});\n\treturn text;\n}\n\n\nvar _FormParagraphs = function(text) {\n//\n//  Params:\n//    $text - string to process with html <p> tags\n//\n\n\t// Strip leading and trailing lines:\n\ttext = text.replace(/^\\n+/g,\"\");\n\ttext = text.replace(/\\n+$/g,\"\");\n\n\tvar grafs = text.split(/\\n{2,}/g);\n\tvar grafsOut = new Array();\n\n\t//\n\t// Wrap <p> tags.\n\t//\n\tvar end = grafs.length;\n\tfor (var i=0; i<end; i++) {\n\t\tvar str = grafs[i];\n\n\t\t// if this is an HTML marker, copy it\n\t\tif (str.search(/~K(\\d+)K/g) >= 0) {\n\t\t\tgrafsOut.push(str);\n\t\t}\n\t\telse if (str.search(/\\S/) >= 0) {\n\t\t\tstr = _RunSpanGamut(str);\n\t\t\tstr = str.replace(/^([ \\t]*)/g,\"<p>\");\n\t\t\tstr += \"</p>\"\n\t\t\tgrafsOut.push(str);\n\t\t}\n\n\t}\n\n\t//\n\t// Unhashify HTML blocks\n\t//\n\tend = grafsOut.length;\n\tfor (var i=0; i<end; i++) {\n\t\t// if this is a marker for an html block...\n\t\twhile (grafsOut[i].search(/~K(\\d+)K/) >= 0) {\n\t\t\tvar blockText = g_html_blocks[RegExp.$1];\n\t\t\tblockText = blockText.replace(/\\$/g,\"$$$$\"); // Escape any dollar signs\n\t\t\tgrafsOut[i] = grafsOut[i].replace(/~K\\d+K/,blockText);\n\t\t}\n\t}\n\n\treturn grafsOut.join(\"\\n\\n\");\n}\n\n\nvar _EncodeAmpsAndAngles = function(text) {\n// Smart processing for ampersands and angle brackets that need to be encoded.\n\t\n\t// Ampersand-encoding based entirely on Nat Irons's Amputator MT plugin:\n\t//   http://bumppo.net/projects/amputator/\n\ttext = text.replace(/&(?!#?[xX]?(?:[0-9a-fA-F]+|\\w+);)/g,\"&amp;\");\n\t\n\t// Encode naked <'s\n\ttext = text.replace(/<(?![a-z\\/?\\$!])/gi,\"&lt;\");\n\t\n\treturn text;\n}\n\n\nvar _EncodeBackslashEscapes = function(text) {\n//\n//   Parameter:  String.\n//   Returns:\tThe string, with after processing the following backslash\n//\t\t\t   escape sequences.\n//\n\n\t// attacklab: The polite way to do this is with the new\n\t// escapeCharacters() function:\n\t//\n\t// \ttext = escapeCharacters(text,\"\\\\\",true);\n\t// \ttext = escapeCharacters(text,\"`*_{}[]()>#+-.!\",true);\n\t//\n\t// ...but we're sidestepping its use of the (slow) RegExp constructor\n\t// as an optimization for Firefox.  This function gets called a LOT.\n\n\ttext = text.replace(/\\\\(\\\\)/g,escapeCharacters_callback);\n\ttext = text.replace(/\\\\([`*_{}\\[\\]()>#+-.!])/g,escapeCharacters_callback);\n\treturn text;\n}\n\n\nvar _DoAutoLinks = function(text) {\n\n\ttext = text.replace(/<((https?|ftp|dict):[^'\">\\s]+)>/gi,\"<a href=\\\"$1\\\">$1</a>\");\n\n\t// Email addresses: <address@domain.foo>\n\n\t/*\n\t\ttext = text.replace(/\n\t\t\t<\n\t\t\t(?:mailto:)?\n\t\t\t(\n\t\t\t\t[-.\\w]+\n\t\t\t\t\\@\n\t\t\t\t[-a-z0-9]+(\\.[-a-z0-9]+)*\\.[a-z]+\n\t\t\t)\n\t\t\t>\n\t\t/gi, _DoAutoLinks_callback());\n\t*/\n\ttext = text.replace(/<(?:mailto:)?([-.\\w]+\\@[-a-z0-9]+(\\.[-a-z0-9]+)*\\.[a-z]+)>/gi,\n\t\tfunction(wholeMatch,m1) {\n\t\t\treturn _EncodeEmailAddress( _UnescapeSpecialChars(m1) );\n\t\t}\n\t);\n\n\treturn text;\n}\n\n\nvar _EncodeEmailAddress = function(addr) {\n//\n//  Input: an email address, e.g. \"foo@example.com\"\n//\n//  Output: the email address as a mailto link, with each character\n//\tof the address encoded as either a decimal or hex entity, in\n//\tthe hopes of foiling most address harvesting spam bots. E.g.:\n//\n//\t<a href=\"&#x6D;&#97;&#105;&#108;&#x74;&#111;:&#102;&#111;&#111;&#64;&#101;\n//\t   x&#x61;&#109;&#x70;&#108;&#x65;&#x2E;&#99;&#111;&#109;\">&#102;&#111;&#111;\n//\t   &#64;&#101;x&#x61;&#109;&#x70;&#108;&#x65;&#x2E;&#99;&#111;&#109;</a>\n//\n//  Based on a filter by Matthew Wickline, posted to the BBEdit-Talk\n//  mailing list: <http://tinyurl.com/yu7ue>\n//\n\n\t// attacklab: why can't javascript speak hex?\n\tfunction char2hex(ch) {\n\t\tvar hexDigits = '0123456789ABCDEF';\n\t\tvar dec = ch.charCodeAt(0);\n\t\treturn(hexDigits.charAt(dec>>4) + hexDigits.charAt(dec&15));\n\t}\n\n\tvar encode = [\n\t\tfunction(ch){return \"&#\"+ch.charCodeAt(0)+\";\";},\n\t\tfunction(ch){return \"&#x\"+char2hex(ch)+\";\";},\n\t\tfunction(ch){return ch;}\n\t];\n\n\taddr = \"mailto:\" + addr;\n\n\taddr = addr.replace(/./g, function(ch) {\n\t\tif (ch == \"@\") {\n\t\t   \t// this *must* be encoded. I insist.\n\t\t\tch = encode[Math.floor(Math.random()*2)](ch);\n\t\t} else if (ch !=\":\") {\n\t\t\t// leave ':' alone (to spot mailto: later)\n\t\t\tvar r = Math.random();\n\t\t\t// roughly 10% raw, 45% hex, 45% dec\n\t\t\tch =  (\n\t\t\t\t\tr > .9  ?\tencode[2](ch)   :\n\t\t\t\t\tr > .45 ?\tencode[1](ch)   :\n\t\t\t\t\t\t\t\tencode[0](ch)\n\t\t\t\t);\n\t\t}\n\t\treturn ch;\n\t});\n\n\taddr = \"<a href=\\\"\" + addr + \"\\\">\" + addr + \"</a>\";\n\taddr = addr.replace(/\">.+:/g,\"\\\">\"); // strip the mailto: from the visible part\n\n\treturn addr;\n}\n\n\nvar _UnescapeSpecialChars = function(text) {\n//\n// Swap back in all the special characters we've hidden.\n//\n\ttext = text.replace(/~E(\\d+)E/g,\n\t\tfunction(wholeMatch,m1) {\n\t\t\tvar charCodeToReplace = parseInt(m1);\n\t\t\treturn String.fromCharCode(charCodeToReplace);\n\t\t}\n\t);\n\treturn text;\n}\n\n\nvar _Outdent = function(text) {\n//\n// Remove one level of line-leading tabs or spaces\n//\n\n\t// attacklab: hack around Konqueror 3.5.4 bug:\n\t// \"----------bug\".replace(/^-/g,\"\") == \"bug\"\n\n\ttext = text.replace(/^(\\t|[ ]{1,4})/gm,\"~0\"); // attacklab: g_tab_width\n\n\t// attacklab: clean up hack\n\ttext = text.replace(/~0/g,\"\")\n\n\treturn text;\n}\n\nvar _Detab = function(text) {\n// attacklab: Detab's completely rewritten for speed.\n// In perl we could fix it by anchoring the regexp with \\G.\n// In javascript we're less fortunate.\n\n\t// expand first n-1 tabs\n\ttext = text.replace(/\\t(?=\\t)/g,\"    \"); // attacklab: g_tab_width\n\n\t// replace the nth with two sentinels\n\ttext = text.replace(/\\t/g,\"~A~B\");\n\n\t// use the sentinel to anchor our regex so it doesn't explode\n\ttext = text.replace(/~B(.+?)~A/g,\n\t\tfunction(wholeMatch,m1,m2) {\n\t\t\tvar leadingText = m1;\n\t\t\tvar numSpaces = 4 - leadingText.length % 4;  // attacklab: g_tab_width\n\n\t\t\t// there *must* be a better way to do this:\n\t\t\tfor (var i=0; i<numSpaces; i++) leadingText+=\" \";\n\n\t\t\treturn leadingText;\n\t\t}\n\t);\n\n\t// clean up sentinels\n\ttext = text.replace(/~A/g,\"    \");  // attacklab: g_tab_width\n\ttext = text.replace(/~B/g,\"\");\n\n\treturn text;\n}\n\n\n//\n//  attacklab: Utility functions\n//\n\n\nvar escapeCharacters = function(text, charsToEscape, afterBackslash) {\n\t// First we have to escape the escape characters so that\n\t// we can build a character class out of them\n\tvar regexString = \"([\" + charsToEscape.replace(/([\\[\\]\\\\])/g,\"\\\\$1\") + \"])\";\n\n\tif (afterBackslash) {\n\t\tregexString = \"\\\\\\\\\" + regexString;\n\t}\n\n\tvar regex = new RegExp(regexString,\"g\");\n\ttext = text.replace(regex,escapeCharacters_callback);\n\n\treturn text;\n}\n\n\nvar escapeCharacters_callback = function(wholeMatch,m1) {\n\tvar charCodeToEscape = m1.charCodeAt(0);\n\treturn \"~E\"+charCodeToEscape+\"E\";\n}\n\nexports.encode = exports.markdown = function (src) {\n   return exports.makeHtml(src);\n};\n\nexports.main = function (system) {\n    var command = system.args.shift();\n    if (!system.args.length) {\n        system.stdout.write(exports.markdown(system.stdin.read())).flush();\n    } else {\n        var arg;\n        while (arg = system.args.shift()) {\n            var out = system.fs.basename(arg, '.md') + '.html';\n            print(out);\n            system.fs.write(out, exports.markdown(system.fs.read(arg)));\n        }\n    }\n};",
               "cache": "exports.get = function(db, docid, setFun, getFun) {\n  db.openDoc(docid, {\n    success : function(doc) {\n      getFun(doc.cache);\n    },\n    error : function() {\n      setFun(function(cache) {\n        db.saveDoc({\n          _id : docid,\n          cache : cache\n        });\n        getFun(cache);\n      });\n    }\n  });\n};\n\nexports.clear = function(db, docid) {\n  db.openDoc(docid, {\n    success : function(doc) {\n      db.removeDoc(doc);\n    },\n    error : function() {}\n  });\n};",
               "list": "// Helpers for writing server-side _list functions in CouchDB\nexports.withRows = function(fun) {\n var f = function() {\n    var row = getRow();\n    return row && fun(row);\n  };\n  f.iterator = true;\n  return f;\n}\n\nexports.send = function(chunk) {\n  send(chunk + \"\\n\")\n}",
               "atom": "// atom feed generator\n// requries E4X support.\n\nfunction f(n) {    // Format integers to have at least two digits.\n    return n < 10 ? '0' + n : n;\n}\n\nfunction rfc3339(date) {\n  return date.getUTCFullYear()   + '-' +\n    f(date.getUTCMonth() + 1) + '-' +\n    f(date.getUTCDate())      + 'T' +\n    f(date.getUTCHours())     + ':' +\n    f(date.getUTCMinutes())   + ':' +\n    f(date.getUTCSeconds())   + 'Z';\n};\n\nexports.header = function(data) {\n  var f = <feed xmlns=\"http://www.w3.org/2005/Atom\"/>;\n  f.title = data.title;\n  f.id = data.feed_id;\n  f.link.@href = data.feed_link;\n  f.link.@rel = \"self\";\n  f.generator = \"CouchApp on CouchDB\";\n  f.updated = rfc3339(data.updated);\n  return f.toXMLString().replace(/\\<\\/feed\\>/,'');\n};\n\nexports.entry = function(data) {\n  var entry = <entry/>;\n  entry.id = data.entry_id;\n  entry.title = data.title;\n  entry.content = data.content;\n  entry.content.@type = (data.content_type || 'html');\n  entry.updated = rfc3339(data.updated);\n  entry.author = <author><name>{data.author}</name></author>;\n  entry.link.@href = data.alternate;\n  entry.link.@rel = \"alternate\";\n  return entry;\n}",
               "linkup": "// this code makes http://example.com into a link, \n// and also handles @name and #hashtag\n\n// todo add [[wiki_links]]\n\nvar mustache = require(\"vendor/couchapp/lib/mustache\");\nexports.encode = function(body, person_prefix, tag_prefix) {\n  body = mustache.escape(body);\n  person_prefix = person_prefix || \"http://twitter.com/\";\n  tag_prefix = tag_prefix || \"http://delicious.com/tag/\";\n  return body.replace(/((ftp|http|https):\\/\\/(\\w+:{0,1}\\w*@)?(\\S+)(:[0-9]+)?(\\/|\\/([\\w#!:.?+=&%@!\\-\\/]))?)/gi,function(a) {\n    return '<a target=\"_blank\" href=\"'+a+'\">'+a+'</a>';\n  }).replace(/\\@([\\w\\-]+)/g,function(user,name) {\n    return '<a href=\"'+person_prefix+encodeURIComponent(name.toLowerCase())+'\">'+user+'</a>';\n  }).replace(/\\#([\\w\\-\\.]+)/g,function(word,tag) {\n    return '<a href=\"'+tag_prefix+encodeURIComponent(tag.toLowerCase())+'\">'+word+'</a>';\n  });\n};",
               "path": "// from couch.js\nfunction encodeOptions(options) {\n  var buf = [];\n  if (typeof(options) == \"object\" && options !== null) {\n    for (var name in options) {\n      if (!options.hasOwnProperty(name)) {continue;}\n      var value = options[name];\n      if (name == \"key\" || name == \"startkey\" || name == \"endkey\") {\n        value = JSON.stringify(value);\n      }\n      buf.push(encodeURIComponent(name) + \"=\" + encodeURIComponent(value));\n    }\n  }\n  if (!buf.length) {\n    return \"\";\n  }\n  return \"?\" + buf.join(\"&\");\n}\n\nfunction concatArgs(array, args) {\n  for (var i=0; i < args.length; i++) {\n    array.push(args[i]);\n  };\n  return array;\n};\n\nfunction makePath(array) {\n  var options, path;\n  \n  if (typeof array[array.length - 1] != \"string\") {\n    // it's a params hash\n    options = array.pop();\n  }\n  path = array.map(function(item) {return encodeURIComponent(item)}).join('/');\n  if (options) {\n    return path + encodeOptions(options);\n  } else {\n    return path;    \n  }\n};\n\nexports.init = function(req) {\n  return {\n    asset : function() {\n      var p = req.path, parts = ['', p[0], p[1] , p[2]];\n      return makePath(concatArgs(parts, arguments));\n    },\n    show : function() {\n      var p = req.path, parts = ['', p[0], p[1] , p[2], '_show'];\n      return makePath(concatArgs(parts, arguments));\n    },\n    list : function() {\n      var p = req.path, parts = ['', p[0], p[1] , p[2], '_list'];\n      return makePath(concatArgs(parts, arguments));\n    },\n    update : function() {\n      var p = req.path, parts = ['', p[0], p[1] , p[2], '_update'];\n      return makePath(concatArgs(parts, arguments));\n    },\n    limit : function(limit) {\n      var query = req.query;\n      var l = query.limit;\n      query.limit = limit;\n      var view = req.path[req.path.length - 1];\n      var list = req.path[req.path.length - 2];\n      var link = this.list(list, view, query);\n      query.limit = l;\n      return link;\n    },\n    older : function(key) {\n      if (!typeof key == \"undefined\") return null;\n      var query = req.query;\n      query.startkey = key;\n      query.skip=1;\n      var view = req.path[req.path.length - 1];\n      var list = req.path[req.path.length - 2];\n      return this.list(list, view, query);\n    },\n    absolute : function(path) {\n      return 'http://' + req.headers.Host + path;\n    }\n  }\n};",
               "md5": "/*\n * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message\n * Digest Algorithm, as defined in RFC 1321.\n * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for more info.\n */\n\n/*\n * Configurable variables. You may need to tweak these to be compatible with\n * the server-side, but the defaults work in most cases.\n */\nvar hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */\nvar b64pad  = \"\"; /* base-64 pad character. \"=\" for strict RFC compliance   */\nvar chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode      */\n\n/*\n * These are the functions you'll usually want to call\n * They take string arguments and return either hex or base-64 encoded strings\n */\nfunction hex_md5(s){ return binl2hex(core_md5(str2binl(s), s.length * chrsz));}\nfunction b64_md5(s){ return binl2b64(core_md5(str2binl(s), s.length * chrsz));}\nfunction str_md5(s){ return binl2str(core_md5(str2binl(s), s.length * chrsz));}\nfunction hex_hmac_md5(key, data) { return binl2hex(core_hmac_md5(key, data)); }\nfunction b64_hmac_md5(key, data) { return binl2b64(core_hmac_md5(key, data)); }\nfunction str_hmac_md5(key, data) { return binl2str(core_hmac_md5(key, data)); }\n\n/*\n * Perform a simple self-test to see if the VM is working\n */\nfunction md5_vm_test()\n{\n  return hex_md5(\"abc\") == \"900150983cd24fb0d6963f7d28e17f72\";\n}\n\n/*\n * Calculate the MD5 of an array of little-endian words, and a bit length\n keep\n */\nfunction core_md5(x, len)\n{\n  /* append padding */\n  x[len >> 5] |= 0x80 << ((len) % 32);\n  x[(((len + 64) >>> 9) << 4) + 14] = len;\n\n  var a =  1732584193;\n  var b = -271733879;\n  var c = -1732584194;\n  var d =  271733878;\n\n  for(var i = 0; i < x.length; i += 16)\n  {\n    var olda = a;\n    var oldb = b;\n    var oldc = c;\n    var oldd = d;\n\n    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);\n    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);\n    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);\n    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);\n    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);\n    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);\n    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);\n    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);\n    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);\n    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);\n    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);\n    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);\n    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);\n    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);\n    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);\n    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);\n\n    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);\n    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);\n    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);\n    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);\n    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);\n    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);\n    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);\n    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);\n    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);\n    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);\n    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);\n    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);\n    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);\n    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);\n    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);\n    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);\n\n    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);\n    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);\n    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);\n    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);\n    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);\n    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);\n    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);\n    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);\n    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);\n    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);\n    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);\n    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);\n    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);\n    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);\n    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);\n    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);\n\n    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);\n    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);\n    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);\n    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);\n    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);\n    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);\n    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);\n    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);\n    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);\n    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);\n    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);\n    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);\n    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);\n    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);\n    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);\n    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);\n\n    a = safe_add(a, olda);\n    b = safe_add(b, oldb);\n    c = safe_add(c, oldc);\n    d = safe_add(d, oldd);\n  }\n  return Array(a, b, c, d);\n\n}\n\n/*\n * These functions implement the four basic operations the algorithm uses.\n */\nfunction md5_cmn(q, a, b, x, s, t)\n{\n  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);\n}\nfunction md5_ff(a, b, c, d, x, s, t)\n{\n  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);\n}\nfunction md5_gg(a, b, c, d, x, s, t)\n{\n  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);\n}\nfunction md5_hh(a, b, c, d, x, s, t)\n{\n  return md5_cmn(b ^ c ^ d, a, b, x, s, t);\n}\nfunction md5_ii(a, b, c, d, x, s, t)\n{\n  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);\n}\n\n/*\n * Calculate the HMAC-MD5, of a key and some data\n */\nfunction core_hmac_md5(key, data)\n{\n  var bkey = str2binl(key);\n  if(bkey.length > 16) bkey = core_md5(bkey, key.length * chrsz);\n\n  var ipad = Array(16), opad = Array(16);\n  for(var i = 0; i < 16; i++)\n  {\n    ipad[i] = bkey[i] ^ 0x36363636;\n    opad[i] = bkey[i] ^ 0x5C5C5C5C;\n  }\n\n  var hash = core_md5(ipad.concat(str2binl(data)), 512 + data.length * chrsz);\n  return core_md5(opad.concat(hash), 512 + 128);\n}\n\n/*\n * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n * to work around bugs in some JS interpreters.\n */\nfunction safe_add(x, y)\n{\n  var lsw = (x & 0xFFFF) + (y & 0xFFFF);\n  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n  return (msw << 16) | (lsw & 0xFFFF);\n}\n\n/*\n * Bitwise rotate a 32-bit number to the left.\n */\nfunction bit_rol(num, cnt)\n{\n  return (num << cnt) | (num >>> (32 - cnt));\n}\n\n/*\n * Convert a string to an array of little-endian words\n * If chrsz is ASCII, characters >255 have their hi-byte silently ignored.\n keep\n */\nfunction str2binl(str)\n{\n  var bin = Array();\n  var mask = (1 << chrsz) - 1;\n  for(var i = 0; i < str.length * chrsz; i += chrsz)\n    bin[i>>5] |= (str.charCodeAt(i / chrsz) & mask) << (i%32);\n  return bin;\n}\n\n/*\n * Convert an array of little-endian words to a string\n */\nfunction binl2str(bin)\n{\n  var str = \"\";\n  var mask = (1 << chrsz) - 1;\n  for(var i = 0; i < bin.length * 32; i += chrsz)\n    str += String.fromCharCode((bin[i>>5] >>> (i % 32)) & mask);\n  return str;\n}\n\n/*\n * Convert an array of little-endian words to a hex string.\n keep\n */\nfunction binl2hex(binarray)\n{\n  var hex_tab = hexcase ? \"0123456789ABCDEF\" : \"0123456789abcdef\";\n  var str = \"\";\n  for(var i = 0; i < binarray.length * 4; i++)\n  {\n    str += hex_tab.charAt((binarray[i>>2] >> ((i%4)*8+4)) & 0xF) +\n           hex_tab.charAt((binarray[i>>2] >> ((i%4)*8  )) & 0xF);\n  }\n  return str;\n}\n\n/*\n * Convert an array of little-endian words to a base-64 string\n */\nfunction binl2b64(binarray)\n{\n  var tab = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n  var str = \"\";\n  for(var i = 0; i < binarray.length * 4; i += 3)\n  {\n    var triplet = (((binarray[i   >> 2] >> 8 * ( i   %4)) & 0xFF) << 16)\n                | (((binarray[i+1 >> 2] >> 8 * ((i+1)%4)) & 0xFF) << 8 )\n                |  ((binarray[i+2 >> 2] >> 8 * ((i+2)%4)) & 0xFF);\n    for(var j = 0; j < 4; j++)\n    {\n      if(i * 8 + j * 6 > binarray.length * 32) str += b64pad;\n      else str += tab.charAt((triplet >> 6*(3-j)) & 0x3F);\n    }\n  }\n  return str;\n}\n\nexports.hex = hex_md5;",
               "mustache": "/*\n * CommonJS-compatible mustache.js module\n *\n * See http://github.com/janl/mustache.js for more info.\n */\n\n/*\n  mustache.js  Logic-less templates in JavaScript\n\n  See http://mustache.github.com/ for more info.\n*/\n\nvar Mustache = function() {\n  var Renderer = function() {};\n\n  Renderer.prototype = {\n    otag: \"{{\",\n    ctag: \"}}\",\n    pragmas: {},\n    buffer: [],\n    pragmas_implemented: {\n      \"IMPLICIT-ITERATOR\": true\n    },\n    context: {},\n\n    render: function(template, context, partials, in_recursion) {\n      // reset buffer & set context\n      if(!in_recursion) {\n        this.context = context;\n        this.buffer = []; // TODO: make this non-lazy\n      }\n\n      // fail fast\n      if(!this.includes(\"\", template)) {\n        if(in_recursion) {\n          return template;\n        } else {\n          this.send(template);\n          return;\n        }\n      }\n\n      template = this.render_pragmas(template);\n      var html = this.render_section(template, context, partials);\n      if(in_recursion) {\n        return this.render_tags(html, context, partials, in_recursion);\n      }\n\n      this.render_tags(html, context, partials, in_recursion);\n    },\n\n    /*\n      Sends parsed lines\n    */\n    send: function(line) {\n      if(line != \"\") {\n        this.buffer.push(line);\n      }\n    },\n\n    /*\n      Looks for %PRAGMAS\n    */\n    render_pragmas: function(template) {\n      // no pragmas\n      if(!this.includes(\"%\", template)) {\n        return template;\n      }\n\n      var that = this;\n      var regex = new RegExp(this.otag + \"%([\\\\w-]+) ?([\\\\w]+=[\\\\w]+)?\" +\n            this.ctag);\n      return template.replace(regex, function(match, pragma, options) {\n        if(!that.pragmas_implemented[pragma]) {\n          throw({message: \n            \"This implementation of mustache doesn't understand the '\" +\n            pragma + \"' pragma\"});\n        }\n        that.pragmas[pragma] = {};\n        if(options) {\n          var opts = options.split(\"=\");\n          that.pragmas[pragma][opts[0]] = opts[1];\n        }\n        return \"\";\n        // ignore unknown pragmas silently\n      });\n    },\n\n    /*\n      Tries to find a partial in the curent scope and render it\n    */\n    render_partial: function(name, context, partials) {\n      name = this.trim(name);\n      if(!partials || partials[name] === undefined) {\n        throw({message: \"unknown_partial '\" + name + \"'\"});\n      }\n      if(typeof(context[name]) != \"object\") {\n        return this.render(partials[name], context, partials, true);\n      }\n      return this.render(partials[name], context[name], partials, true);\n    },\n\n    /*\n      Renders inverted (^) and normal (#) sections\n    */\n    render_section: function(template, context, partials) {\n      if(!this.includes(\"#\", template) && !this.includes(\"^\", template)) {\n        return template;\n      }\n\n      var that = this;\n      // CSW - Added \"+?\" so it finds the tighest bound, not the widest\n      var regex = new RegExp(this.otag + \"(\\\\^|\\\\#)\\\\s*(.+)\\\\s*\" + this.ctag +\n              \"\\n*([\\\\s\\\\S]+?)\" + this.otag + \"\\\\/\\\\s*\\\\2\\\\s*\" + this.ctag +\n              \"\\\\s*\", \"mg\");\n\n      // for each {{#foo}}{{/foo}} section do...\n      return template.replace(regex, function(match, type, name, content) {\n        var value = that.find(name, context);\n        if(type == \"^\") { // inverted section\n          if(!value || that.is_array(value) && value.length === 0) {\n            // false or empty list, render it\n            return that.render(content, context, partials, true);\n          } else {\n            return \"\";\n          }\n        } else if(type == \"#\") { // normal section\n          if(that.is_array(value)) { // Enumerable, Let's loop!\n            return that.map(value, function(row) {\n              return that.render(content, that.create_context(row),\n                partials, true);\n            }).join(\"\");\n          } else if(that.is_object(value)) { // Object, Use it as subcontext!\n            return that.render(content, that.create_context(value),\n              partials, true);\n          } else if(typeof value === \"function\") {\n            // higher order section\n            return value.call(context, content, function(text) {\n              return that.render(text, context, partials, true);\n            });\n          } else if(value) { // boolean section\n            return that.render(content, context, partials, true);\n          } else {\n            return \"\";\n          }\n        }\n      });\n    },\n\n    /*\n      Replace {{foo}} and friends with values from our view\n    */\n    render_tags: function(template, context, partials, in_recursion) {\n      // tit for tat\n      var that = this;\n\n      var new_regex = function() {\n        return new RegExp(that.otag + \"(=|!|>|\\\\{|%)?([^\\\\/#\\\\^]+?)\\\\1?\" +\n          that.ctag + \"+\", \"g\");\n      };\n\n      var regex = new_regex();\n      var tag_replace_callback = function(match, operator, name) {\n        switch(operator) {\n        case \"!\": // ignore comments\n          return \"\";\n        case \"=\": // set new delimiters, rebuild the replace regexp\n          that.set_delimiters(name);\n          regex = new_regex();\n          return \"\";\n        case \">\": // render partial\n          return that.render_partial(name, context, partials);\n        case \"{\": // the triple mustache is unescaped\n          return that.find(name, context);\n        default: // escape the value\n          return that.escape(that.find(name, context));\n        }\n      };\n      var lines = template.split(\"\\n\");\n      for(var i = 0; i < lines.length; i++) {\n        lines[i] = lines[i].replace(regex, tag_replace_callback, this);\n        if(!in_recursion) {\n          this.send(lines[i]);\n        }\n      }\n\n      if(in_recursion) {\n        return lines.join(\"\\n\");\n      }\n    },\n\n    set_delimiters: function(delimiters) {\n      var dels = delimiters.split(\" \");\n      this.otag = this.escape_regex(dels[0]);\n      this.ctag = this.escape_regex(dels[1]);\n    },\n\n    escape_regex: function(text) {\n      // thank you Simon Willison\n      if(!arguments.callee.sRE) {\n        var specials = [\n          '/', '.', '*', '+', '?', '|',\n          '(', ')', '[', ']', '{', '}', '\\\\'\n        ];\n        arguments.callee.sRE = new RegExp(\n          '(\\\\' + specials.join('|\\\\') + ')', 'g'\n        );\n      }\n      return text.replace(arguments.callee.sRE, '\\\\$1');\n    },\n\n    /*\n      find `name` in current `context`. That is find me a value\n      from the view object\n    */\n    find: function(name, context) {\n      name = this.trim(name);\n\n      // Checks whether a value is thruthy or false or 0\n      function is_kinda_truthy(bool) {\n        return bool === false || bool === 0 || bool;\n      }\n\n      var value;\n      if(is_kinda_truthy(context[name])) {\n        value = context[name];\n      } else if(is_kinda_truthy(this.context[name])) {\n        value = this.context[name];\n      }\n\n      if(typeof value === \"function\") {\n        return value.apply(context);\n      }\n      if(value !== undefined) {\n        return value;\n      }\n      // silently ignore unkown variables\n      return \"\";\n    },\n\n    // Utility methods\n\n    /* includes tag */\n    includes: function(needle, haystack) {\n      return haystack.indexOf(this.otag + needle) != -1;\n    },\n\n    /*\n      Does away with nasty characters\n    */\n    escape: function(s) {\n      s = String(s === null ? \"\" : s);\n      return s.replace(/&(?!\\w+;)|[\"<>\\\\]/g, function(s) {\n        switch(s) {\n        case \"&\": return \"&amp;\";\n        case \"\\\\\": return \"\\\\\\\\\";\n        case '\"': return '\\\"';\n        case \"<\": return \"&lt;\";\n        case \">\": return \"&gt;\";\n        default: return s;\n        }\n      });\n    },\n\n    // by @langalex, support for arrays of strings\n    create_context: function(_context) {\n      if(this.is_object(_context)) {\n        return _context;\n      } else {\n        var iterator = \".\";\n        if(this.pragmas[\"IMPLICIT-ITERATOR\"]) {\n          iterator = this.pragmas[\"IMPLICIT-ITERATOR\"].iterator;\n        }\n        var ctx = {};\n        ctx[iterator] = _context;\n        return ctx;\n      }\n    },\n\n    is_object: function(a) {\n      return a && typeof a == \"object\";\n    },\n\n    is_array: function(a) {\n      return Object.prototype.toString.call(a) === '[object Array]';\n    },\n\n    /*\n      Gets rid of leading and trailing whitespace\n    */\n    trim: function(s) {\n      return s.replace(/^\\s*|\\s*$/g, \"\");\n    },\n\n    /*\n      Why, why, why? Because IE. Cry, cry cry.\n    */\n    map: function(array, fn) {\n      if (typeof array.map == \"function\") {\n        return array.map(fn);\n      } else {\n        var r = [];\n        var l = array.length;\n        for(var i = 0; i < l; i++) {\n          r.push(fn(array[i]));\n        }\n        return r;\n      }\n    }\n  };\n\n  return({\n    name: \"mustache.js\",\n    version: \"0.3.1-dev\",\n\n    /*\n      Turns a template and view into HTML\n    */\n    to_html: function(template, view, partials, send_fun) {\n      var renderer = new Renderer();\n      if(send_fun) {\n        renderer.send = send_fun;\n      }\n      renderer.render(template, view, partials);\n      if(!send_fun) {\n        return renderer.buffer.join(\"\\n\");\n      }\n    },\n    escape : function(text) {\n      return new Renderer().escape(text);\n    }\n  });\n}();\n\nexports.name = Mustache.name;\nexports.version = Mustache.version;\n\nexports.to_html = Mustache.to_html;\nexports.escape = Mustache.escape;",
               "docform": "// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n// use this file except in compliance with the License.  You may obtain a copy\n// of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n// License for the specific language governing permissions and limitations under\n// the License.\n\n// turn the form into deep json\n// field names like 'author-email' get turned into json like\n// {\"author\":{\"email\":\"quentin@example.com\"}}\n// acts on doc by reference, so you can safely pass non-form fields through\nfunction formToDeepJSON(form, fields, doc) {\n  form = $(form);\n  fields.forEach(function(field) {\n    var val = form.find(\"[name=\"+field+\"]\").val();\n    if (!val) {return;}\n    var parts = field.split('-');\n    var frontObj = doc, frontName = parts.shift();\n    while (parts.length > 0) {\n      frontObj[frontName] = frontObj[frontName] || {};\n      frontObj = frontObj[frontName];\n      frontName = parts.shift();\n    }\n    frontObj[frontName] = val;\n  });\n}\n\nfunction onSubmit(form, db, doc, opts) {\n  formToDeepJSON(form, opts.fields, doc);\n  if (opts.beforeSave) {opts.beforeSave(doc);}\n  db.saveDoc(localFormDoc, {\n    success : function(resp) {\n      if (opts.success) {opts.success(resp, doc);}\n    }\n  });\n};\n\nfunction applyFields(form, doc) {\n  \n};\nexports.applyFields = applyFields;\n\n// docForm applies CouchDB behavior to HTML forms.\n// todo make this a couch.app plugin\nfunction docForm(formSelector, opts) {\n  var localFormDoc = {};\n  opts = opts || {};\n  opts.fields = opts.fields || [];\n\n  // Apply the behavior\n  $(formSelector).submit(function(e) {\n\n\n    return false;\n  });\n\n  // populate form from an existing doc\n  function docToForm(doc) {\n    var form = $(formSelector);\n    // fills in forms\n    opts.fields.forEach(function(field) {\n      var parts = field.split('-');\n      var run = true, frontObj = doc, frontName = parts.shift();\n      while (frontObj && parts.length > 0) {                \n        frontObj = frontObj[frontName];\n        frontName = parts.shift();\n      }\n      if (frontObj && frontObj[frontName]) {\n        form.find(\"[name=\"+field+\"]\").val(frontObj[frontName]);              \n      }\n    });            \n  }\n\n  if (opts.id) {\n    db.openDoc(opts.id, {\n      success: function(doc) {\n        if (opts.onLoad) {opts.onLoad(doc);}\n        localFormDoc = doc;\n        docToForm(doc);\n        }});\n      } else if (opts.template) {\n        if (opts.onLoad) {opts.onLoad(opts.template);}\n        localFormDoc = opts.template;\n        docToForm(localFormDoc);\n      }\n      var instance = {\n        deleteDoc : function(opts) {\n          opts = opts || {};\n          if (confirm(\"Really delete this document?\")) {                \n            db.removeDoc(localFormDoc, opts);\n          }\n        },\n        localDoc : function() {\n          formToDeepJSON(formSelector, opts.fields, localFormDoc);\n          return localFormDoc;\n        }\n      };\n      return instance;\n    }"
           },
           "metadata": {
               "name": "couchapp",
               "fetch_uri": "git://github.com/couchapp/couchapp.git",
               "description": "official couchapp vendor"
           }
       }
   },
   "language": "javascript",
   "views": {
       "GetDocByEntityAndFormInstance": {
           "map": "function(doc)\r\n{  \r\n    if (doc.entityId && doc.formId)\r\n \t{ \r\n    \tvar instanceId = ( doc.instanceId ? doc.instanceId: 1 );\r\n\t    emit([doc.entityId, doc.formId, instanceId], doc);\r\n\t}\r\n}"
       },
       "GetLatestAnswersByOwnerAndQuestionAndFormInstance": {
           "map": "function(doc)\r\n{\r\n\tvar instanceId = ( doc.instanceId ? doc.instanceId : 1 );\r\n    if(doc.ownerId)\r\n  \t{\r\n\t    var questions = doc[\"questions\"];\r\n\t\tvar simpleTables = doc[\"simple_tables\"];\r\n\t\tvar complexTables = doc[\"complex_tables\"];\r\n\t\tif (questions)\r\n\t\t{\r\n\t\t    for(key in questions)\r\n            {\r\n\t\t\t    \r\n\t\t\t\tvar question=questions[key];\r\n                var answers = question.answerValues;\r\n\t\t\t\tvar answersArray = new Array();\r\n                if(answers)\r\n\t\t\t\t{\r\n                    \r\n                    for(var i=0; i<answers.length; i++)\r\n                    {\r\n\t\t\t\t\tif(answers[i].ansValue != '')\r\n                        answersArray[i] = answers[i].ansValue;\r\n                    }\r\n                }\r\n\t\t\t\tif(answersArray.length>0)\r\n\t\t\t\t{\r\n\t\t\t\t\temit([doc.ownerId, key, instanceId], {'updatedDate': doc.updatedDate, 'questions': question, 'questionType': 'questions'});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tif (simpleTables)\r\n\t\t{\r\n\t\t    for(key in simpleTables)\r\n            {\r\n\t\t\t    var answersArray = new Array();\r\n\t\t\t\tvar simpleTable=simpleTables[key];\r\n\t\t\t\tsimpleTable[\"uuid\"] = key;\r\n\t\t\t\tvar questions = simpleTable[\"questions\"];\r\n\t\t\t\tfor (var questionId in questions)\r\n\t\t\t\t{\r\n\t\t\t\t\tvar question=questions[questionId];\r\n\t\t\t\t\tvar answers = question.answerValues;\r\n\t\t\t\t\tif(answers)\r\n\t\t\t\t\t{\r\n                    \r\n\t\t\t\t\t\tfor(var i=0; i<answers.length; i++)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\tif(answers[i].ansValue != '')\r\n\t\t\t\t\t\t\tanswersArray[i] = answers[i].ansValue;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\tif(answersArray.length>0)\r\n\t\t\t\t{\r\n\t\t\t\t\temit([doc.ownerId, key, instanceId], {'updatedDate': doc.updatedDate, 'simple_tables': simpleTable, 'questionType': 'simple_tables'});\r\n\t\t\t\t}\r\n                   \r\n\t\t\t}\r\n\t\t}\r\n\t\tif (complexTables)\r\n\t\t{\r\n\t\t    for(key in complexTables)\r\n            {\r\n\t\t\t    var answersArray = new Array();\r\n\t\t\t\tvar complexTable=complexTables[key];\r\n\t\t\t\tvar rows = complexTable[\"rows\"];\r\n\t\t\t\tfor(var i=0; i<rows.length; i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tvar row = rows[i];\r\n\t\t\t\t\t\r\n\t\t\t\t\tfor (tableId in row)\r\n\t\t\t\t\t{\r\n//\t\t\t\t\t\t emit([doc.ownerId, key], {'updatedDate': row[tableId]});\r\n\t\t\t\t\t\tvar question = row[tableId];\r\n\t\t\t\t\t\tvar answers = question[\"answerValues\"];\r\n//\t\t\t\t\t\tvar singleAnswer = answers.length;\r\n\t\t\t\t\t\tif (answers)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tfor(var j=0; j<answers.length; j++)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tif(answers[j].ansValue != '')\r\n\t\t\t\t\t\t\t\tanswersArray[j] = answers[j].ansValue;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif(answersArray.length >0)\r\n\t\t\t\t{\r\n                    emit([doc.ownerId, key, instanceId], {'updatedDate': doc.updatedDate, 'complex_tables': complexTable, 'questionType': 'complex_tables'});\r\n\t\t\t\t}\r\n//\t\t\t\temit([doc.ownerId, key], {'updatedDate': doc.updatedDate, 'complex_tables': complexTable, 'questionType': 'complex_tables'});\r\n\t\t\t}\r\n\t\t}\r\n        \r\n    }\r\n}"
       },
       "GetAnswersByOwnerAndQuestionAndFormInstance": {
           "map": "function(doc) {\r\n\tvar instanceId = ( doc.instanceId ? doc.instanceId : 1 );\r\n\tif (doc.ownerId && doc.formId)\r\n\t{\r\n\t\tvar questions = doc['questions'];\r\n\t\tif (questions) {\r\n\t\t    for (key in questions) {\r\n\t\t        var question = questions[key];\r\n\t\t        var answers = question.answerValues;\r\n\t\t        if (answers) \r\n\t\t\t\t{\r\n\t\t\t\t\tvar answersArray = new Array();\r\n\t\t\t\t\tfor ( var i = 0; i < answers.length; i++)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tanswersArray[i] = answers[i].ansValue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\temit([ doc.ownerId, doc.formId, key, instanceId ], answersArray);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar simpleTables = doc['simple_tables'];\r\n\t\tif (simpleTables) \r\n\t\t{\r\n\t\t\tfor (tkey in simpleTables)\r\n\t\t\t{\r\n\t\t\t\tvar questions = simpleTables[tkey]['questions'];\r\n\t\t\t\tif (questions) \r\n\t\t\t\t{\r\n\t\t\t\t\tfor (key in questions) \r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tvar question = questions[key];\r\n\t\t\t\t\t\tvar answers = question.answerValues;\r\n\t\t\t\t\t\tif (answers) \r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tvar answersArray = new Array();\r\n\t\t\t\t\t\t\tfor ( var i = 0; i < answers.length; i++)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tanswersArray[i] = answers[i].ansValue;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\temit([ doc.ownerId, doc.formId, key, instanceId ], answersArray);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar complexTables = doc['complex_tables'];\r\n\t\tif (complexTables) \r\n\t\t{\r\n\t\t\tfor (tkey in complexTables) \r\n\t\t\t{\r\n\t\t\t\tvar rows = complexTables[tkey]['rows'];\r\n\t\t\t\tif (rows) \r\n\t\t\t\t{\r\n\t\t\t\t\tfor (rkey in rows)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tvar row = rows[rkey];\r\n\t\t\t\t\t\tvar rowId = null;\r\n\t\t\t\t\t\tfor (qkey in row)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif(qkey == 'rowId')\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\trowId = row[qkey];\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfor (qkey in row) \r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tvar question = row[qkey];\r\n\t\t\t\t\t\t\tvar answers = question.answerValues;\r\n\t\t\t\t\t\t\tif (answers) \r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tvar answersArray = new Array();\r\n\t\t\t\t\t\t\t\tfor ( var i = 0; i < answers.length; i++) \r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tanswersArray[i] = answers[i].ansValue;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tif(rowId) \r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\temit([ doc.ownerId, doc.formId, rowId, qkey, instanceId ], answersArray);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\telse \r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\temit([ doc.ownerId, doc.formId, rkey, qkey, instanceId ], answersArray);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\n/*function(doc)\r\n{\r\n    if(doc.ownerId)\r\n  \t{\r\n\t    var questions = doc[\"questions\"];\r\n\t\tif (questions)\r\n\t\t{\r\n\t\t    for(key in questions)\r\n            {\r\n\t\t\t    var question=questions[key];\r\n                var answers = question.answerValues;\r\n                if(answers)\r\n\t\t\t\t{\r\n                    var answersArray = new Array();\r\n                    for(var i=0; i<answers.length; i++)\r\n                    {\r\n                        answersArray[i] = answers[i].ansValue;\r\n                    }\r\n                    emit([doc.ownerId, key], answersArray);\r\n                }\r\n\t\t\t}\r\n\t\t}\r\n        \r\n    }\r\n}\r\n*/"
       },
       "GetDocsByOwnerAndForm": {
           "map": "function(doc)\r\n{  \r\n    if (doc.ownerId && doc.formId)\r\n \t{   \r\n\t    emit([doc.ownerId, doc.formId], doc);\r\n\t}\r\n}"
       },
       "GetDocRefsByEntity": {
           "map": "function(doc){\r\n    if (doc.entityId )\r\n    {\r\n        emit(doc.entityId, { '_id':doc._id, '_rev':doc._rev });\r\n    }\r\n}"
       },
       "GetDocByFormInstanceAndOwner": {
           "map": "function(doc)\r\n{  \r\n    if (doc.formId && doc.ownerId)\r\n \t{ \r\n    \tvar instanceId = ( doc.instanceId ? doc.instanceId: 1 );\r\n    \temit([ doc.formId, doc.ownerId, instanceId], doc);\r\n\t}\r\n}"
       },
       "GetAnswersByEntityAndQuestion": {
           "map": "function(doc)\r\n{\r\n    if(doc.entityId)\r\n  \t{\r\n\t    var questions = doc[\"questions\"];\r\n\t\tif (questions)\r\n\t\t{\r\n\t\t    for(key in questions)\r\n            {\r\n\t\t\t    /* get question data */\r\n\t\t\t\tvar question=questions[key];\r\n                var answers = question.answerValues;\r\n                if(answers)\r\n\t\t\t\t{\r\n                    var answersArray = new Array();\r\n                    for(var i=0; i<answers.length; i++)\r\n                    {\r\n                        answersArray[i] = answers[i].ansValue;\r\n                    }\r\n                    emit([doc.entityId, key], answersArray);\r\n                }\r\n\t\t\t}\r\n\t\t}\r\n        \r\n    }\r\n}"
       },
       "GetDocRefsByOwnerAndFormInstance": {
           "map": "function(doc)\r\n{  \r\n    if (doc.ownerId && doc.formId)\r\n \t{   \r\n    \tvar instanceId = ( doc.instanceId ? doc.instanceId: 1 );\r\n\t    emit([doc.ownerId, doc.formId, instanceId], { '_id':doc._id, '_rev':doc._rev });\r\n\t}\r\n}"
       },
       "GetDocsByFormAndOwner": {
           "map": "function(doc)\r\n{  \r\n    if (doc.formId && doc.ownerId)\r\n \t{ \r\n    \temit([ doc.formId, doc.ownerId ], doc);\r\n\t}\r\n}"
       },
       "GetDocIdsByModule": {
           "map": "function(doc)\r\n{  \r\n    if (doc.moduleId)\r\n \t{   \r\n\t    emit(doc.moduleId, doc._id);\r\n\t}\r\n}"
       },
       "GetDocRefByForm": {
           "map": "function(doc){\r\n    if (doc.formId )\r\n    {\r\n        emit(doc.formId, { '_id':doc._id, '_rev':doc._rev });\r\n    }\r\n}"
       },
       "GetDocRefsByOwner": {
           "map": "function(doc){\r\n    if (doc.ownerId )\r\n    {\r\n        emit(doc.ownerId, { '_id':doc._id, '_rev':doc._rev });\r\n    }\r\n}"
       },
       "GetDocsByModule": {
           "map": "function(doc)\r\n{  \r\n    if (doc.moduleId)\r\n \t{   \r\n\t    emit(doc.moduleId, doc);\r\n\t}\r\n}"
       },
       "GetDocByOwnerAndFormInstance": {
           "map": "function(doc)\r\n{  \r\n    if (doc.ownerId && doc.formId)\r\n \t{   \r\n    \tvar instanceId = ( doc.instanceId ? doc.instanceId: 1 );\r\n\t    emit([doc.ownerId, doc.formId, instanceId], doc);\r\n\t}\r\n}"
       },
       "GetDocsByForm": {
           "map": "function(doc)\r\n{  \r\n    if (doc.formId)\r\n \t{   \r\n\t    emit(doc.formId, doc);\r\n\t}\r\n}"
       },
       "GetDocsByOwnerAndModule": {
           "map": "function(doc)\r\n{  \r\n    if (doc.ownerId && doc.moduleId)\r\n \t{   \r\n\t    emit(doc.ownerId+\"_\"+doc.moduleId, doc);\r\n\t}\r\n}"
       },
       "GetAnswersByOwnerAndQuestion": {
           "map": "function(doc) {\r\n\tif (doc.ownerId && doc.formId)\r\n\t{\r\n\t\tvar questions = doc['questions'];\r\n\t\tif (questions) {\r\n\t\t    for (key in questions) {\r\n\t\t        var question = questions[key];\r\n\t\t        var answers = question.answerValues;\r\n\t\t        if (answers) \r\n\t\t\t\t{\r\n\t\t\t\t\tvar answersArray = new Array();\r\n\t\t\t\t\tfor ( var i = 0; i < answers.length; i++)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tanswersArray[i] = answers[i].ansValue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\temit([ doc.ownerId, doc.formId, key ], answersArray);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar simpleTables = doc['simple_tables'];\r\n\t\tif (simpleTables) \r\n\t\t{\r\n\t\t\tfor (tkey in simpleTables)\r\n\t\t\t{\r\n\t\t\t\tvar questions = simpleTables[tkey]['questions'];\r\n\t\t\t\tif (questions) \r\n\t\t\t\t{\r\n\t\t\t\t\tfor (key in questions) \r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tvar question = questions[key];\r\n\t\t\t\t\t\tvar answers = question.answerValues;\r\n\t\t\t\t\t\tif (answers) \r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tvar answersArray = new Array();\r\n\t\t\t\t\t\t\tfor ( var i = 0; i < answers.length; i++)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tanswersArray[i] = answers[i].ansValue;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\temit([ doc.ownerId, doc.formId, key ], answersArray);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar complexTables = doc['complex_tables'];\r\n\t\tif (complexTables) \r\n\t\t{\r\n\t\t\tfor (tkey in complexTables) \r\n\t\t\t{\r\n\t\t\t\tvar rows = complexTables[tkey]['rows'];\r\n\t\t\t\tif (rows) \r\n\t\t\t\t{\r\n\t\t\t\t\tfor (rkey in rows)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tvar row = rows[rkey];\r\n\t\t\t\t\t\tvar rowId = null;\r\n\t\t\t\t\t\tfor (qkey in row)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif(qkey == 'rowId')\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\trowId = row[qkey];\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfor (qkey in row) \r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tvar question = row[qkey];\r\n\t\t\t\t\t\t\tvar answers = question.answerValues;\r\n\t\t\t\t\t\t\tif (answers) \r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tvar answersArray = new Array();\r\n\t\t\t\t\t\t\t\tfor ( var i = 0; i < answers.length; i++) \r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tanswersArray[i] = answers[i].ansValue;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\tif(rowId) \r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\temit([ doc.ownerId, doc.formId, rowId, qkey ], answersArray);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\telse \r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\temit([ doc.ownerId, doc.formId, rkey, qkey ], answersArray);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\n/*function(doc)\r\n{\r\n    if(doc.ownerId)\r\n  \t{\r\n\t    var questions = doc[\"questions\"];\r\n\t\tif (questions)\r\n\t\t{\r\n\t\t    for(key in questions)\r\n            {\r\n\t\t\t    var question=questions[key];\r\n                var answers = question.answerValues;\r\n                if(answers)\r\n\t\t\t\t{\r\n                    var answersArray = new Array();\r\n                    for(var i=0; i<answers.length; i++)\r\n                    {\r\n                        answersArray[i] = answers[i].ansValue;\r\n                    }\r\n                    emit([doc.ownerId, key], answersArray);\r\n                }\r\n\t\t\t}\r\n\t\t}\r\n        \r\n    }\r\n}\r\n*/"
       },
       "GetDocsByOwner": {
           "map": "function(doc)\r\n{  \r\n    if (doc.ownerId)\r\n \t{   \r\n\t    emit(doc.ownerId, doc);\r\n\t}\r\n}"
       },
       "GetFilteredDocByOwnerAndFormInstance": {
           "map": "function(doc)\n{\n    function wasAnswered( question ) \n    {\n        var answerValues = question.answerValues;\n        for ( var index=0; index < answerValues.length; ++index ) \n        {\n            if ( answerValues[index]['ansValue'] != '' )\n                return true;\n        }\n        return false;\n    }\n\n    function removeBlankAnswers(doc)\n    {\n        if ( doc.questions )\n        {\n            for ( index in doc.questions )\n            {    \n                var question = doc.questions[index];\n                if ( ! wasAnswered( question ) ) \n                {\n                    // Remove questions with blank answers\n                    delete doc.questions[index];\n                }\n            }\n        }\n        return doc;\n    }\n    \n    if (doc.ownerId && doc.formId)\n    {\n    \tvar instanceId = ( doc.instanceId ? doc.instanceId: 1 );\n        emit([doc.ownerId, doc.formId, instanceId], removeBlankAnswers( doc ));\n    }\n}"
       }
   },
   "lists": {
       "formToXml": "function(head, req) {\r\n  var template = this.templates.form;\r\n  var Mustache = require(\"vendor/couchapp/lib/mustache\");\r\n  var caCURE = require(\"hcit/lib/cacure\"); \r\n  var row;\r\n  var document = new Object();\r\n\r\n  while (row = getRow())\r\n  {\r\n\tvar doc = row[\"value\"];\r\n\tdocument = caCURE.prepareDoc(doc);\r\n/*\tdocument.revision = doc[\"_rev\"];\r\n    document.entityId = doc[\"entityId\"];\r\n\tdocument.name = doc[\"formName\"];\r\n\tdocument.formId = doc.formId;\r\n    var questions = doc[\"questions\"];\r\n\tvar questionsArray = new Array();\r\n    for (key in questions)\r\n    {\r\n        var question = questions[key];\r\n\t\tquestionsArray.push(question);\r\n    }\r\n\tdocument[\"questions\"] = questionsArray;\r\n*/\t\r\n  }\r\n  return Mustache.to_html(template, document);\r\n}",
       "formToXmlAllOwners": "function(head, req) {\r\n  var template = this.templates.formAllEntities;\r\n  var Mustache = require(\"vendor/couchapp/lib/mustache\");\r\n  var caCURE = require(\"hcit/lib/cacure\"); \r\n  var row;\r\n  var globalDocument = new Object();\r\n  var owners = new Array();\r\n  globalDocument[\"owners\"] = owners;\r\n\r\n  while (row = getRow())\r\n  {\r\n\tvar doc = row[\"value\"];\r\n\tdocument = caCURE.prepareDoc(doc);\r\n\tvar ownerObject = new Object();\r\n\tglobalDocument.name=document.name;\r\n\tglobalDocument.formId = document.formId;\r\n\townerObject.ownerId = doc[\"ownerId\"];\r\n\r\n\townerObject[\"questions\"] = document[\"questions\"];\r\n\townerObject[\"simpleTables\"] = document[\"simpleTables\"];\r\n\townerObject[\"complexTables\"] = document[\"complexTables\"];\r\n\t\r\n    owners.push(ownerObject);\r\n  }\r\n  return Mustache.to_html(template, globalDocument);\r\n}",
       "formsToXml": "function(head, req) {\r\n  var template = this.templates.forms;\r\n  var Mustache = require(\"vendor/couchapp/lib/mustache\");\r\n  var caCURE = require(\"hcit/lib/cacure\"); \r\n  var row;\r\n  var formsDocument = new Object();\r\n  var formsArray = new Array();\r\n  var document = new Object();\r\n\r\n  while (row = getRow())\r\n  {\r\n\tvar doc = row[\"value\"];\r\n\tdocument = caCURE.prepareDoc(doc);\r\n\tdocument[\"ownerId\"] = doc.ownerId;\r\n\tdocument[\"moduleId\"] = doc.moduleId;\r\n\tformsArray.push(document);\t\r\n  }\r\n  formsDocument[\"forms\"] = formsArray;\r\n  return Mustache.to_html(template, formsDocument);\r\n}"
   },
   "hcit": {
       "lib": {
           "cacure": "exports.prepareDoc = function(doc)\r\n{\r\n/*    var document = new Object();\r\n    document.revision = doc[\"_rev\"];\r\n    document.entityId = doc[\"entityId\"];\r\n\tdocument.name = doc[\"formName\"];\r\n\tdocument.formId = doc.formId;\r\n    var questions = doc[\"questions\"];\r\n\tvar questionsArray = new Array();\r\n    for (key in questions)\r\n    {\r\n        var question = questions[key];\r\n\t\tquestionsArray.push(question);\r\n    }\r\n\tdocument[\"questions\"] = questionsArray;\r\n\treturn document;\r\n\t*/\r\n\t\r\n\tvar document = new Object();\r\n    document.revision = doc[\"_rev\"];\r\n    document.instanceId = doc[\"instanceId\"] ? doc[\"instanceId\"] : 1;\r\n    document.ownerId = doc[\"ownerId\"];\r\n\tdocument.name = doc[\"formName\"];\r\n\tdocument.formId = doc.formId;\r\n    var questions = doc[\"questions\"];\r\n    var simpleTables = doc[\"simple_tables\"];\r\n\tvar complexTables = doc[\"complex_tables\"];\r\n\tvar questionsArray = new Array();\r\n\tvar simpleTablesArray = new Array();\r\n\tvar complexTablesArray = new Array();\r\n\tvar key;\r\n    for (key in questions)\r\n    {\r\n        var question = questions[key];\r\n\t\tquestionsArray.push(question);\r\n    }\r\n    for (key in simpleTables)\r\n    {\r\n        var simpleTable = simpleTables[key];\r\n        var tableObject = new Object();\r\n        tableObject[\"tableText\"] = simpleTable[\"table_text\"];\r\n        tableObject[\"uuid\"] = key;\r\n        tableObject[\"sn\"] = simpleTable[\"short_name\"];\r\n        var tableQuestionsArray = new Array();\r\n        var tableQuestions = simpleTable[\"questions\"];\r\n        for (tableQuestionId in tableQuestions)\r\n        {\r\n        \tvar tableQuestion = tableQuestions[tableQuestionId];\r\n\t\t\ttableQuestionsArray.push(tableQuestion);\r\n        }\r\n        tableObject[\"questions\"] = tableQuestionsArray;\r\n\t\tsimpleTablesArray.push(tableObject);\r\n    }\r\n    for (key in complexTables)\r\n    {\r\n        var complexTable = complexTables[key];\r\n    \tvar tableObject = new Object();\r\n        var metadata = complexTable[\"metadata\"];\r\n        tableObject[\"tableText\"] = metadata[\"table_text\"];\r\n        tableObject[\"sn\"] = metadata[\"short_name\"];\r\n        tableObject[\"uuid\"] = complexTable[\"uuid\"];\r\n        var rows = complexTable[\"rows\"];\r\n        var rowsArray = new Array();\r\n        var columnsOrder = metadata[\"columns_order\"];\r\n        for (var i=0; i<rows.length; i++)\r\n        {\r\n        \tvar row = rows[i];\r\n        \tvar rowObject = new Object();\r\n        \tvar columnsArray = new Array();\r\n        \tfor(var j=0; j<columnsOrder.length; j++)\r\n        \t{\r\n        \t\tvar currentColumn = columnsOrder[j];\r\n        \t\tvar column = row[currentColumn];\r\n        \t\tcolumnsArray.push(column);\r\n        \t}\r\n        \trowObject[\"columns\"] = columnsArray;\r\n        \trowsArray.push(rowObject);\r\n        }\r\n        tableObject[\"rows\"] = rowsArray;\r\n\r\n\t\tcomplexTablesArray.push(tableObject);\r\n    }\r\n\tdocument[\"questions\"] = questionsArray;\r\n\tdocument[\"simpleTables\"] = simpleTablesArray;\r\n\tdocument[\"complexTables\"] = complexTablesArray;\r\n\treturn document;\r\n}"
       }
   },
   "evently": {
       "profile": {
           "profileReady": {
               "mustache": "<p>Most applications will customize this template (<tt>ddoc.evently.profile.profileReady.mustache</tt>) for user input.</p>\n\n<div class=\"avatar\">\n  {{#gravatar_url}}<img src=\"{{gravatar_url}}\"/>{{/gravatar_url}}\n  <div class=\"name\">\n    {{name}}\n  </div>\n</div>\n\n<form>\n  <label>New message from {{nickname}}: <input type=\"text\" name=\"message\" size=60 value=\"\"></label>\n</form>\n\n<div style=\"clear:left;\"></div>",
               "selectors": {
                   "form": {
                       "submit": "function() {\n  var form = $(this);\n  var fdoc = form.serializeObject();\n  fdoc.created_at = new Date();\n  fdoc.profile = $$(\"#profile\").profile;\n  $$(this).app.db.saveDoc(fdoc, {\n    success : function() {\n      form[0].reset();\n    }\n  });\n  return false;\n};"
                   }
               }
           }
       },
       "items": {
           "_changes": {
               "query": {
                   "limit": 50,
                   "descending": "true",
                   "view": "recent-items"
               },
               "data": "function(data) {\n  // $.log(data)\n  var p;\n  return {\n    items : data.rows.map(function(r) {\n      p = (r.value && r.value.profile) || {};\n      p.message = r.value && r.value.message;\n      return p;\n    })\n  }\n};",
               "mustache": "<p>Customize this format here: <tt>ddoc.evently.items._changes.mustache</tt></p>\n<h3>Recent Messages</h3>\n<ul>\n  {{#items}}\n    <li>\n      <div class=\"avatar\">\n        {{#gravatar_url}}<img src=\"{{gravatar_url}}\" alt=\"{{name}}\"/>{{/gravatar_url}}\n        <div class=\"name\">\n          {{nickname}}\n        </div>\n      </div>\n      <p>{{message}}</p>\n      <div style=\"clear:left;\"></div>\n    </li>\n  {{/items}}\n</ul>\n<p><em>Protip:</em> If you setup continuous replication between this database and a remote one, this list will reflect remote changes in near real-time.</p>\n<p>This would be a good place to add pagination.</p>"
           }
       }
   },
   "updates": {
   },
   "couchapp": {
       "manifest": [
           "couchapp.json",
           "evently/",
           "evently/items/",
           "evently/items/_changes/",
           "evently/items/_changes/data.js",
           "evently/items/_changes/mustache.html",
           "evently/items/_changes/query.json",
           "evently/profile/",
           "evently/profile/profileReady/",
           "evently/profile/profileReady/mustache.html",
           "evently/profile/profileReady/selectors/",
           "evently/profile/profileReady/selectors/form/",
           "evently/profile/profileReady/selectors/form/submit.js",
           "hcit/",
           "hcit/lib/",
           "hcit/lib/cacure.js",
           "language",
           "lists/",
           "lists/formsToXml.js",
           "lists/formToXml.js",
           "lists/formToXmlAllOwners.js",
           "README.md",
           "shows/",
           "templates/",
           "templates/form.xml",
           "templates/formAllEntities.xml",
           "templates/forms.xml",
           "updates/",
           "vendor/",
           "vendor/couchapp/",
           "vendor/couchapp/evently/",
           "vendor/couchapp/evently/account/",
           "vendor/couchapp/evently/account/adminParty/",
           "vendor/couchapp/evently/account/adminParty/mustache.html",
           "vendor/couchapp/evently/account/doLogin.js",
           "vendor/couchapp/evently/account/doLogout.js",
           "vendor/couchapp/evently/account/doSignup.js",
           "vendor/couchapp/evently/account/loggedIn/",
           "vendor/couchapp/evently/account/loggedIn/after.js",
           "vendor/couchapp/evently/account/loggedIn/data.js",
           "vendor/couchapp/evently/account/loggedIn/mustache.html",
           "vendor/couchapp/evently/account/loggedIn/selectors.json",
           "vendor/couchapp/evently/account/loggedOut/",
           "vendor/couchapp/evently/account/loggedOut/mustache.html",
           "vendor/couchapp/evently/account/loggedOut/selectors.json",
           "vendor/couchapp/evently/account/loginForm/",
           "vendor/couchapp/evently/account/loginForm/after.js",
           "vendor/couchapp/evently/account/loginForm/mustache.html",
           "vendor/couchapp/evently/account/loginForm/selectors/",
           "vendor/couchapp/evently/account/loginForm/selectors/a[href=#signup].json",
           "vendor/couchapp/evently/account/loginForm/selectors/form/",
           "vendor/couchapp/evently/account/loginForm/selectors/form/submit.js",
           "vendor/couchapp/evently/account/signupForm/",
           "vendor/couchapp/evently/account/signupForm/after.js",
           "vendor/couchapp/evently/account/signupForm/mustache.html",
           "vendor/couchapp/evently/account/signupForm/selectors/",
           "vendor/couchapp/evently/account/signupForm/selectors/a[href=#login].json",
           "vendor/couchapp/evently/account/signupForm/selectors/form/",
           "vendor/couchapp/evently/account/signupForm/selectors/form/submit.js",
           "vendor/couchapp/evently/account/_init.js",
           "vendor/couchapp/evently/profile/",
           "vendor/couchapp/evently/profile/loggedIn.js",
           "vendor/couchapp/evently/profile/loggedOut/",
           "vendor/couchapp/evently/profile/loggedOut/after.js",
           "vendor/couchapp/evently/profile/loggedOut/mustache.html",
           "vendor/couchapp/evently/profile/noProfile/",
           "vendor/couchapp/evently/profile/noProfile/data.js",
           "vendor/couchapp/evently/profile/noProfile/mustache.html",
           "vendor/couchapp/evently/profile/noProfile/selectors/",
           "vendor/couchapp/evently/profile/noProfile/selectors/form/",
           "vendor/couchapp/evently/profile/noProfile/selectors/form/submit.js",
           "vendor/couchapp/evently/profile/profileReady/",
           "vendor/couchapp/evently/profile/profileReady/after.js",
           "vendor/couchapp/evently/profile/profileReady/data.js",
           "vendor/couchapp/evently/profile/profileReady/mustache.html",
           "vendor/couchapp/evently/README.md",
           "vendor/couchapp/lib/",
           "vendor/couchapp/lib/atom.js",
           "vendor/couchapp/lib/cache.js",
           "vendor/couchapp/lib/docform.js",
           "vendor/couchapp/lib/linkup.js",
           "vendor/couchapp/lib/list.js",
           "vendor/couchapp/lib/markdown.js",
           "vendor/couchapp/lib/md5.js",
           "vendor/couchapp/lib/mustache.js",
           "vendor/couchapp/lib/path.js",
           "vendor/couchapp/lib/redirect.js",
           "vendor/couchapp/metadata.json",
           "vendor/couchapp/README.md",
           "views/",
           "views/GetAnswersByEntityAndQuestion/",
           "views/GetAnswersByEntityAndQuestion/map.js",
           "views/GetAnswersByOwnerAndQuestion/",
           "views/GetAnswersByOwnerAndQuestion/map.js",
           "views/GetAnswersByOwnerAndQuestionAndFormInstance/",
           "views/GetAnswersByOwnerAndQuestionAndFormInstance/map.js",
           "views/GetDocByEntityAndFormInstance/",
           "views/GetDocByEntityAndFormInstance/map.js",
           "views/GetDocByFormInstanceAndOwner/",
           "views/GetDocByFormInstanceAndOwner/map.js",
           "views/GetDocByOwnerAndFormInstance/",
           "views/GetDocByOwnerAndFormInstance/map.js",
           "views/GetDocIdsByModule/",
           "views/GetDocIdsByModule/map.js",
           "views/GetDocRefByForm/",
           "views/GetDocRefByForm/map.js",
           "views/GetDocRefsByEntity/",
           "views/GetDocRefsByEntity/map.js",
           "views/GetDocRefsByOwner/",
           "views/GetDocRefsByOwner/map.js",
           "views/GetDocRefsByOwnerAndFormInstance/",
           "views/GetDocRefsByOwnerAndFormInstance/map.js",
           "views/GetDocsByForm/",
           "views/GetDocsByForm/map.js",
           "views/GetDocsByFormAndOwner/",
           "views/GetDocsByFormAndOwner/map.js",
           "views/GetDocsByModule/",
           "views/GetDocsByModule/map.js",
           "views/GetDocsByOwner/",
           "views/GetDocsByOwner/map.js",
           "views/GetDocsByOwnerAndForm/",
           "views/GetDocsByOwnerAndForm/map.js",
           "views/GetDocsByOwnerAndModule/",
           "views/GetDocsByOwnerAndModule/map.js",
           "views/GetFilteredDocByOwnerAndFormInstance/",
           "views/GetFilteredDocByOwnerAndFormInstance/map.js",
           "views/GetLatestAnswersByOwnerAndQuestionAndFormInstance/",
           "views/GetLatestAnswersByOwnerAndQuestionAndFormInstance/map.js"
       ],
       "signatures": {
           ".svn/entries": "af6ccf2b12b18005c967e79e7b41a58c",
           "vendor/couchapp/.svn/text-base/jquery.mustache.js.svn-base": "0bfbc929b6d5500aacfa860c783550d8",
           "index.html": "76c97adecaf523ac0599f6806881e4a6",
           "vendor/couchapp/.svn/text-base/jquery.pathbinder.js.svn-base": "b0638decac2661bcd6c1dfbc932a266f",
           "style/.svn/text-base/main.css.svn-base": "9ebbd747b41569f1a99f7f6847bf79b8",
           "vendor/couchapp/.svn/text-base/loader.js.svn-base": "5c771689c7faebedd7be76f2e1638c6f",
           "style/.svn/entries": "14c3a8b7773cfca8ba5f940944c8ddb1",
           "vendor/couchapp/loader.js": "5c771689c7faebedd7be76f2e1638c6f",
           "vendor/couchapp/.svn/entries": "96a1d32eb5bae3b54d94994a75b5b454",
           "vendor/couchapp/.svn/text-base/jquery.couch.app.js.svn-base": "21530f1b1ca10e83d80a0c2a145d250f",
           "vendor/couchapp/jquery.mustache.js": "0bfbc929b6d5500aacfa860c783550d8",
           ".svn/text-base/index.html.svn-base": "76c97adecaf523ac0599f6806881e4a6",
           "vendor/couchapp/.svn/text-base/jquery.couch.app.util.js.svn-base": "3dcb7ba87d7eb3bf9dad48acd85355a8",
           "vendor/couchapp/jquery.pathbinder.js": "b0638decac2661bcd6c1dfbc932a266f",
           "vendor/couchapp/jquery.couch.app.js": "21530f1b1ca10e83d80a0c2a145d250f",
           "vendor/couchapp/jquery.evently.js": "428bcff5d4894bb4c2362ecd788f580a",
           "style/main.css": "9ebbd747b41569f1a99f7f6847bf79b8",
           "vendor/couchapp/jquery.couch.app.util.js": "3dcb7ba87d7eb3bf9dad48acd85355a8",
           "vendor/couchapp/.svn/text-base/jquery.evently.js.svn-base": "428bcff5d4894bb4c2362ecd788f580a"
       },
       "description": "CouchApp",
       "objects": {
       },
       "name": "Name of your CouchApp"
   },
   "README": "## Generated by CouchApp\n\nCouchApps are web applications which can be served directly from [CouchDB](http://couchdb.apache.org). This gives them the nice property of replicating just like any other data stored in CouchDB. They are also simple to write as they can use the built-in jQuery libraries and plugins that ship with CouchDB.\n\n[More info about CouchApps here.](http://couchapp.org)\n\n## Deploying this app\n\nAssuming you just cloned this app from git, and you have changed into the app directory in your terminal, you want to push it to your CouchDB with the CouchApp command line tool, like this:\n\n    couchapp push . http://name:password@hostname:5984/mydatabase\n\nIf you don't have a password on your CouchDB (admin party) you can do it like this (but it's a bad, idea, set a password):\n\n    couchapp push . http://hostname:5984/mydatabase\n\nIf you get sick of typing the URL, you should setup a `.couchapprc` file in the root of your directory. Remember not to check this into version control as it will have passwords in it.\n\nThe `.couchapprc` file should have contents like this:\n\n    {\n      \"env\" : {\n        \"public\" : {\n          \"db\" : \"http://name:pass@mycouch.couchone.com/mydatabase\"\n        },\n        \"default\" : {\n          \"db\" : \"http://name:pass@localhost:5984/mydatabase\"\n        }\n      }\n    }\n\nNow that you have the `.couchapprc` file set up, you can push your app to the CouchDB as simply as:\n\n    couchapp push\n\nThis pushes to the `default` as specified. To push to the `public` you'd run:\n\n    couchapp push public\n\nOf course you can continue to add more deployment targets as you see fit, and give them whatever names you like.",
   "shows": {
   }
}